#include <stdio.h>
#include <stdlib.h>
#include "FileReader.h"

#include "Account.h"
#include "Character.h"
#include "StringList.h"
#include "Config.h"
#include "DirectoryAccess.h"

#include "Character.h"
#include "Item.h"
#include "Globals.h"
#include "ZoneDef.h"
#include "Util.h"
#include "ConfigString.h"
#include "Inventory.h"
#include "util/Log.h"
#include "md5.hh"

//char *GetValueOfKey(MULTISTRING &extract, const char *key);  //External function

//extern char GAuxBuf[];

AccountManager g_AccountManager;

PermissionInfo PermissionDef[] = {
	{Perm_Account, 0, Permission_TweakOther,     "tweakother" },
	{Perm_Account, 0, Permission_TweakSelf,      "tweakself" },
	{Perm_Account, 0, Permission_TweakNPC,       "tweaknpc" },
	{Perm_Account, 0, Permission_TweakClient,    "tweakclient" },
	{Perm_Account, 0, Permission_SysChat,        "syschat" },
	{Perm_Account, 0, Permission_GMChat,         "gmchat" },
	{Perm_Account, 0, Permission_RegionChat,     "regionchat" },
	{Perm_Account, 0, Permission_ForumPost,      "forumpost" },
	{Perm_Account, 0, Permission_ForumAdmin,     "forumadmin" },
	{Perm_Account, 0, Permission_ItemGive,       "itemgive" },
	{Perm_Account, 0, Permission_Debug,          "debug" },
	{Perm_Account, 0, Permission_Sage,           "sage" },
	{Perm_Account, 0, Permission_FastLoad,       "fastload" },
	{Perm_Account, 0, Permission_Admin,          "admin" },
	{Perm_Account, 0, Permission_PasswordReset,  "passwordreset" },
	{Perm_Account, 0, Permission_Invisible,      "invisible" },
	{Perm_Account, 0, Permission_SelfDiag,       "selfdiag" },
	{Perm_Account, 0, Permission_Troll,          "troll" },
	{Perm_Account, 0, Permission_TrollChat,      "trollchat" },
	{Perm_Account, 0, Permission_Builder,        "builder" },
	{Perm_Account, 0, Permission_FullSet,        "fullset" }
};
const int MaxPermissionDef = sizeof(PermissionDef) / sizeof(PermissionInfo);

//Byte sequence generated by http://www.random.org/
//WARNING: Changing this will invalidate the keys of any existing accounts.
const char RandomSalt[] = "W7UDynoSUED5zbdA5ldiSlxV9DX0Fssl8VdhRUZWkG6D6XRGETXKRVdJMI2LAGvZyawgHkD26OIKDxz4" \
"xrWdol3RQp8JJ79lmCRQHfMBVa0jXyUaZSxq23lRNBjzMBKymxXmfZ9ugfuvIbV9NpF4b7K5GgACcWy7" \
"Xwz2P4wLYknUtIFLLZcQqFhlrcXRpsbtmc4JzKJqKPrsLlKby0PF3EGhSOLWfXO0bRrvpvXoxtuDnh2Z" \
"F6GUqW4X9JeFvMbLV8mcMm1i37SNPMwILzy1JqbYTeVtJLDozCVftVo4dBQJcgb9CMLGeCxO5DT2Xw5X" \
"gcyJgYXFFwRatjdPyLs4boM3aCTyWsNyNFfHArHati2mFGBS5CXqfazIhau6hyMlkxmGR3WUxioCpzq4" \
"H7q6usn8oSETobwEqsAqdVeMk06621glbeV9yofr7SapSTnp2xXSyklDcr5hOiEoFdCLkePQQoAEAtEx" \
"jKLu0aTpKMRmysq5kTiS";

//
// AccessToken
//
AccessToken :: AccessToken()
{
	expire = 0;
	uses = 0;
	tokenType = ACCESS_TOKEN;
	accountID = 0;
}
AccessToken :: ~AccessToken()
{
}

//
// AccountData
//

AccountData :: AccountData()
{
	ClearAll();
}

AccountData :: ~AccountData()
{
	ClearAll();
}

void AccountData :: ClearAll(void)
{
	ID = 0;
	memset(Name, 0, sizeof(Name));
	//memset(AuthPass, 0, sizeof(AuthPass));
	memset(AuthData, 0, sizeof(AuthData));
	memset(RegKey, 0, sizeof(RegKey));
	RecoveryKeys.clear();
	memset(CharacterSet, 0, sizeof(CharacterSet));
	//memset(ResCharacterSet, 0, sizeof(ResCharacterSet));
	memset(PermissionSet, 0, sizeof(PermissionSet));
	GroveName.clear();
	AccountQuests.clear();
	BuildPermissionList.clear();
	preferenceList.PrefList.clear();
	PendingMinorUpdates = 0;

	SuspendDurationSec = 0;
	SuspendTimeSec = 0;
	MaxCharacters = DEFAULT_CHARACTER_SLOTS;

	LastLogOnTimeSec = 0;
	CreatedTimeSec = 0;
	ConsecutiveDaysLoggedIn = 0;

	Credits = 0;
	DeliveryBoxSlots = 0;
	VeteranLevel = 0;
	VeteranImported = false;
	inventory.ClearAll();
//	deliveryInventory.clear();

	memset(&LastLogOn, 0, sizeof(LastLogOn));

	SessionLoginCount = 0;
	ExpireTime = 0;

	PlayerStats.Clear();

	SiteSession.Clear();

	//CurrentVaultSize = DEFAULT_VAULT_SIZE;
}

void AccountData::FillAuthorizationHash(const char *hash)
{
	Util::SafeCopy(AuthData, hash, sizeof(AuthData));
}
void AccountData::FillRegistrationKey(const char *key)
{
	Util::SafeCopy(RegKey, key, sizeof(RegKey));
}

bool AccountData :: MatchAuthData(const char *str)
{
	if(strcmp(AuthData, str) == 0)
		return true;

	return false;
}

void AccountData :: ResolveCharacters(const char *debugName)
{
	/* TODO: Revamp
	int ci;
	int NChar = 0;
	for(ci = 0; ci < MaxCharacters; ci++)
	{
		int index = CharacterSet[ci];
		if(index > 0)
		{
			int ret = GetCharacterIndex(index);
			if(ret >= 0)
			{
				ResCharacterSet[NChar] = ret;
				NChar++;
			}
			else
				g_Log.AddMessageFormat("Warning: cannot find character index %d for account %s.", index, debugName);
		}
	}
	NumCharacters = NChar;
	*/
}

int AccountData :: GetCharacterCount(void)
{
	int count = 0;
	for(int a = 0; a < MAX_CHARACTER_SLOTS; a++)
		if(CharacterSet[a] != 0)
			count++;
	return count;
}

bool AccountData :: SetPermission(short filterType, const char *name, bool value)
{
	int a;
	for(a = 0; a < MaxPermissionDef; a++)
	{
		if(PermissionDef[a].type == filterType)
		{
			if(strcmp(PermissionDef[a].name, name) == 0)
			{
				if(value == true)
					PermissionSet[PermissionDef[a].index] |= PermissionDef[a].flag;
				else
					PermissionSet[PermissionDef[a].index] &= (~(PermissionDef[a].flag));
				return true;
			}
		}
	}
	return false;
}

bool AccountData :: HasPermission(short permissionSet, unsigned int permissionFlag)
{
	if(PermissionSet[permissionSet] & permissionFlag)
		return true;

	return false;
}

int AccountData :: GetFreeCharacterSlot(void)
{
	for(int a = 0; a < MaxCharacters; a++)
		if(CharacterSet[a] == 0)
			return a;
	return -1;
}

bool AccountData :: CheckBuildPermission(int zoneID, int pagex, int pagey)
{
	if(HasPermission(Perm_Account, Permission_Builder)) {
		return true;
	}
	for(size_t i = 0; i < BuildPermissionList.size(); i++)
	{
		BuildPermissionArea &bpa = BuildPermissionList[i];
		if(bpa.ZoneID == zoneID)
		{
			if(pagex >= bpa.x1 && pagex <= bpa.x2)
				if(pagey >= bpa.y1 && pagey <= bpa.y2)
					return true;
		}
	}
	return false;
}

bool AccountData :: CheckBuildPermissionAdv(int zoneID, int PageSize, float posx, float posz)
{
	if(HasPermission(Perm_Account, Permission_Builder)) {
		return true;
	}
	//Need increased resolution since negative positions may round to zero.
	int px = (int)posx;
	int pz = (int)posz;
	for(size_t i = 0; i < BuildPermissionList.size(); i++)
	{
		BuildPermissionArea &bpa = BuildPermissionList[i];
		if(bpa.ZoneID == zoneID)
		{
			// Position 0,0 effectively ranges from 0,0 to PageSize-1,PageSize-1
			// So we need to expand the x2,y2 boundary to include for an extra cell.
			int x1 = bpa.x1 * PageSize;
			int y1 = bpa.y1 * PageSize;
			int x2 = ((bpa.x2 + 1) * PageSize) - 1;
			int y2 = ((bpa.y2 + 1) * PageSize) - 1;
			if(px >= x1 && px <= x2)
				if(pz >= y1 && pz <= y2)
					return true;
		}
	}
	return false;
}

bool AccountData :: HasCharacterID(int CDefID)
{
	for(int a = 0; a < MAX_CHARACTER_SLOTS; a++)
		if(CharacterSet[a] == CDefID)
			return true;
	return false;
}


bool AccountData :: HasAccountCompletedQuest(int QuestID) {
	return std::find(AccountQuests.begin(), AccountQuests.end(), QuestID) != AccountQuests.end();
}

bool AccountData :: HasBuildZone(BuildPermissionArea &bpa)
{
	for(size_t i = 0; i < BuildPermissionList.size(); i++)
	{
		BuildPermissionArea &has = BuildPermissionList[i];
		if(has.ZoneID != bpa.ZoneID)
			continue;
		if(has.x1 != bpa.x1)
			continue;
		if(has.x2 != bpa.x2)
			continue;
		if(has.y1 != bpa.y1)
			continue;
		if(has.y2 != bpa.y2)
			continue;
		return true;
	}
	return false;
}

void AccountData :: SetBan(int minutes)
{
	SuspendDurationSec = minutes * 60;
	SuspendTimeSec = g_PlatformTime.getAbsoluteSeconds();
	PendingMinorUpdates++;
}

bool AccountData ::ExpandDeliveryBoxes()
{
	 if(DeliveryBoxSlots < MAX_DELIVERY_BOX_SLOTS) {
		 DeliveryBoxSlots++;
		 PendingMinorUpdates++;
		 return true;
	 }
	 return false;
}

bool AccountData ::ExpandCharacterSlots()
{
	 if(MaxCharacters < MAX_CHARACTER_SLOTS) {
		 MaxCharacters++;
		 PendingMinorUpdates++;
		 return true;
	 }
	 return false;
}

void AccountData :: ClearBan(void)
{
	SuspendDurationSec = 0;
	SuspendTimeSec = 0;
	PendingMinorUpdates++;
}

void AccountData :: AdjustSessionLoginCount(short count)
{
	SessionLoginCount += count;

	if(SessionLoginCount > 0)
	{
		ExpireTime = PlatformTime::MAX_TIME;
	}
	else
	{
		ExpireTime = g_ServerTime + EXPIRE_TIME;
	}
}

int AccountData :: GetSessionLoginCount(void)
{
	return SessionLoginCount;
}

/* Write the account data to a file.  The file must be open. */
void AccountData :: SaveToStream(FILE *output)
{
	fprintf(output, "[ENTRY]\r\n");
	fprintf(output, "ID=%d\r\n", ID);
	fprintf(output, "Name=%s\r\n", Name);
	fprintf(output, "Auth=%s\r\n", AuthData);
	fprintf(output, "RegKey=%s\r\n", RegKey);
	if(MaxCharacters != DEFAULT_CHARACTER_SLOTS)
		fprintf(output, "MaxCharacters=%d\r\n", MaxCharacters);
	fprintf(output, "RecoveryKeys=%s\r\n", RecoveryKeys.c_str());
	if(SuspendTimeSec >= 0)
	{
		fprintf(output, "SuspendTime=%lu\r\n", SuspendTimeSec);
		fprintf(output, "SuspendDuration=%lu\r\n", SuspendDurationSec);
	}
	fprintf(output, "LastLogOn=%s\r\n", LastLogOn);
	fprintf(output, "LastLogOnTime=%lu\r\n", LastLogOnTimeSec);
	fprintf(output, "CreatedTime=%lu\r\n", CreatedTimeSec);
	fprintf(output, "ConsecutiveDaysLoggedIn=%d\r\n", ConsecutiveDaysLoggedIn);
	fprintf(output, "Credits=%d\r\n", Credits);
	fprintf(output, "DeliveryBoxSlots=%d\r\n", DeliveryBoxSlots);
	fprintf(output, "VeteranLevel=%d\r\n", VeteranLevel);
	fprintf(output, "VeteranImported=%d\r\n", VeteranImported ? 1 : 0);
	fprintf(output, "\r\n");

	fprintf(output, "Characters=");
	for(int a = 0; a < MaxCharacters; a++)
	{
		if(CharacterSet[a] == 0)
			continue;

		if(a > 0)
			fputc(',', output);
		fprintf(output, "%d", CharacterSet[a]);
	}
	fprintf(output, "\r\n");

	int write = 0;
	for(int a = 0; a < MaxPermissionDef; a++)
	{
		if((PermissionSet[PermissionDef[a].index] & PermissionDef[a].flag) == PermissionDef[a].flag)
		{
			if(write == 0)
				fprintf(output, "Permissions=");
			if(write > 0)
				fputc(',', output);
			write++;

			fprintf(output, "%s", PermissionDef[a].name);

			if(write >= 5)
			{
				fprintf(output, "\r\n");
				write = 0;
			}
		}
	}
	if(write > 0)
		fprintf(output, "\r\n");

	Util::WriteString(output, "GroveName", GroveName);
	PlayerStats.SaveToStream(output);


//	Util::WriteString(output, "xCSRF", SiteSession.xCSRF);
//	Util::WriteString(output, "SessionName", SiteSession.sessionName);
//	Util::WriteString(output, "SessionID", SiteSession.sessionID);
	for(size_t i = 0; i < BuildPermissionList.size(); i++)
	{
		BuildPermissionArea &bpa = BuildPermissionList[i];
		fprintf(output, "Build=%d,%d,%d,%d,%d\r\n", bpa.ZoneID, bpa.x1, bpa.y1, bpa.x2, bpa.y2);
	}

	for(size_t i = 0; i < AccountQuests.size(); i++)
		fprintf(output, "AccountQuest=%d\r\n", AccountQuests[i]);


	//Preferences
	for(size_t i = 0; i < preferenceList.PrefList.size(); i++)
		fprintf(output, "Pref=%s,%s\r\n", preferenceList.PrefList[i].name.c_str(), preferenceList.PrefList[i].value.c_str());
	fprintf(output, "\r\n");

	int a, b;
	for(a = 0; a < MAXCONTAINER; a++)
		{
			for(b = 0; b < (int)inventory.containerList[a].size(); b++)
			{
				InventorySlot *slot = &inventory.containerList[a][b];
				fprintf(output, "%s=%lu,%d",
					GetContainerNameFromID((slot->CCSID & CONTAINER_ID) >> 16),
					slot->CCSID & CONTAINER_SLOT,
					slot->IID );

				bool extend = false;
				if(slot->count > 0 || slot->customLook != 0 || slot->bindStatus != 0 || slot->secondsRemaining != -1)
					extend = true;

				if(extend == true) {
					fprintf(output, ",%d,%d,%d,%ld", slot->count, slot->customLook, slot->bindStatus, slot->AdjustTimes());
				}

				fprintf(output, "\r\n");
			}
		}


	//TODO:VAULT fprintf(output, "CurrentVaultSize=%d\r\n", CurrentVaultSize);
//	for(size_t i = 0; i < vaultInventory.size(); i++)
//		vaultInventory[i].SaveToAccountStream("bank", output);
//	for(size_t i = 0; i < deliveryInventory.size(); i++)
//		deliveryInventory[i].SaveToAccountStream("delivery", output);

	characterCache.SaveToStream(output);

	PendingMinorUpdates = 0;
}

/* Determine if the account is ready for unloading. Normally honors login time unless forced
to unload, such as during shutdown.*/
bool AccountData :: QualifyGarbage(bool force)
{
	if(SessionLoginCount > 0)
		return false;

	if(PendingMinorUpdates > 0)
		return false;

	if(g_ServerTime >= ExpireTime || force == true)
		return true;

	return false;
}

//Generate a password hash that the EE client would send, provided the plain text for username and password.
//The supplied password to this function must be the raw unhashed password.
//  MD5(username + ":" + MD5(password) + ":" + salt)
void AccountData :: GenerateClientPasswordHash(const char *username, const char *password, std::string &outputString)
{
	MD5 passwordHash;
	passwordHash.update((unsigned char*)password, strlen(password));
	passwordHash.finalize();

	std::string buf;

	buf = username;
	buf.append(":");
	buf.append(passwordHash.hex_digest());
	buf.append(":");
	buf.append(g_AuthKey);

	MD5 finalHash;
	finalHash.update((unsigned char*)buf.c_str(), buf.size());
	finalHash.finalize();

	outputString = finalHash.hex_digest();
}

//Generate a new hash from a string, in the form of MD5(inputstring + salt)
void AccountData :: GenerateSaltedHash(const char *inputString, std::string &outputString)
{
	const char *salt = (char*)RandomSalt; //Need to typecast for the append to work.

	std::string s;
	s.append(inputString);
	s.append(salt, sizeof(RandomSalt));

	MD5 hash;
	hash.update((unsigned char*)s.c_str(), s.size());
	hash.finalize();

	outputString = hash.hex_digest();
}

void AccountData :: GenerateAndApplyRegistrationKeyRecovery(void)
{
	if(IsRegistrationKeyEmpty() == true)
		return;

	ConfigString str(RecoveryKeys);

	std::string rkhash;
	GenerateSaltedHash(RegKey, rkhash);
	str.SetKeyValue("regkey", rkhash.c_str());

	std::string result;
	str.GenerateString(result);
	
	RecoveryKeys = result;
	PendingMinorUpdates++;
}

bool AccountData :: MatchRecoveryKey(const char *type, const char *hash)
{
	ConfigString keys(RecoveryKeys);
	if(keys.HasKey(type) == false)
		return false;

	std::string value;
	keys.GetValueString(type, value);
	
	if(value.compare(hash) == 0)
		return true;

	return false;
}

void AccountData :: SetNewPassword(const char *username, const char *plainTextPassword)
{
	std::string pwHash;
	GenerateClientPasswordHash(username, plainTextPassword, pwHash);

	//Extra step for server-side passwords.
	AccountData::GenerateSaltedHash(pwHash.c_str(), pwHash);

	FillAuthorizationHash(pwHash.c_str());
	PendingMinorUpdates++;
}

void AccountData :: SetNewRegistrationKey(const char *regkey)
{
	FillRegistrationKey(regkey);
	GenerateAndApplyRegistrationKeyRecovery();
}

bool AccountData :: MatchRegistrationKey(const char *regkey)
{
	if(regkey == NULL)
		return false;

	//If the key wiped, automatically check the recovery key and restore the key if necessary.
	CheckRecoveryRegistrationKey(regkey);

	if(IsRegistrationKeyEmpty() == true)
		return false;

	if(strlen(regkey) != strlen(RegKey))
		return false;
	if(strcmp(RegKey, regkey) != 0)
		return false;

	return true;
}

bool AccountData :: IsRegistrationKeyEmpty(void)
{
	//Consider single digit keys to be wiped and invalid.
	if(strlen(RegKey) <= 1)
		return true;

	return false;
}

void AccountData :: CheckRecoveryRegistrationKey(const char *regkey)
{
	if(IsRegistrationKeyEmpty() == false)
		return;

	//Only try to restore keys if the registration key field is empty.

	ConfigString str(RecoveryKeys);
	if(str.HasKey("regkey") == true)
	{
		//Hash the provided key 
		std::string convertedKey;
		GenerateSaltedHash(regkey, convertedKey);

		//Retrieve the recovery key
		std::string recoveryKey;
		str.GetValueString("regkey", recoveryKey);

		if(convertedKey.compare(recoveryKey) == 0)
		{
			//It matches, restore the key.
			FillRegistrationKey(regkey);
			PendingMinorUpdates++;

			AccountQuickData *aqd = g_AccountManager.GetAccountQuickDataByUsername(Name);
			if(aqd != NULL)
			{
				aqd->mRegKey = regkey;
				g_AccountManager.AccountQuickDataChanges.AddChange();
			}

			g_Log.AddMessageFormat("Account [%s] missing registration key was restored from recovery key.", Name);
		}
	}
}


void AccountData :: ReadFromJSON(Json::Value &value)
{
	strcpy(Name, value.get("name", "").asCString());
	ID = value.get("id", 0).asInt();

	characterCache.cacheData.clear();

	Json::Value characters = value["characters"];
	for(Json::Value::iterator it = characters.begin(); it != characters.end() ; ++it) {
		CharacterCacheEntry cce;
		cce.display_name = characters.get("name", "").asString();
		cce.level = characters.get("level", 0).asInt();
		cce.profession = characters.get("profession", 0).asInt();
		cce.appearance = characters.get("appearance", 0).asString();
		cce.eq_appearance = characters.get("eqAppearance", 0).asString();
		characterCache.cacheData.push_back(cce);
	}
	SuspendDurationSec = value["suspend"].asLargestUInt();
	SuspendTimeSec = value["suspended"].asLargestUInt();
	strcpy(LastLogOn, value["logon"].asCString());
	LastLogOnTimeSec = value["logonTime"].asLargestUInt();
	CreatedTimeSec = value["createdTime"].asLargestUInt();
	ConsecutiveDaysLoggedIn = value["days"].asInt();
	Credits = value["credits"].asInt();
	DeliveryBoxSlots = value["deliveryBoxes"].asInt();
	VeteranLevel = value["veteranLevel"].asInt();
	VeteranImported = value["veteranImported"].asBool();
	MaxCharacters = value["max"].asInt();
	GroveName = value["grove"].asString();
	PlayerStats.Clear();
	if(value.isMember("playerStats")) {
		PlayerStats.ReadFromJSON(value["playerStats"]);
	}
}

void AccountData :: WriteToJSON(Json::Value &value)
{
	value["name"] = Name;
	value["id"] = ID;

	Json::Value characters;
	for(std::vector<CharacterCacheEntry>::iterator it = characterCache.cacheData.begin(); it != characterCache.cacheData.end(); ++it) {
		CharacterCacheEntry cce = *it;
		Json::Value character;
		character["name"] = cce.display_name;
		character["level"] = cce.level;
		character["profession"] = cce.profession;
		character["appearance"] = cce.appearance;
		character["eqAppearance"] = cce.eq_appearance;
		characters[cce.display_name] = character;
	}
	for(int i = 0 ; i < MAX_CHARACTER_SLOTS; i++) {
		if(CharacterSet[i] > 0)
			characters.append(CharacterSet[i]);
	}
	value["characters"] = characters;
	value["suspend"] = Json::UInt64(SuspendDurationSec);
	value["suspended"] = Json::UInt64(SuspendTimeSec);
	value["logon"] = LastLogOn;
	value["logonTime"] = Json::UInt64(LastLogOnTimeSec);
	value["createdTime"] = Json::UInt64(CreatedTimeSec);
	value["days"] = ConsecutiveDaysLoggedIn;
	value["credits"] = Credits;
	value["deliveryBoxes"] = DeliveryBoxSlots;
	value["veteranLevel"] = VeteranLevel;
	value["veteranImported"] = VeteranImported;
	value["grove"] = GroveName;
	value["max"] = MaxCharacters;

	Json::Value ps;
	PlayerStats.WriteToJSON(ps);
	value["playerStats"] = ps;
}

AccountManager :: AccountManager()
{
	NextCharacterID = DEFAULT_CHARACTER_ID;
	NextAccountID = 1;
	cs.Init();
	cs.SetDebugName("CS_ACCOUNT");
}

AccountManager :: ~AccountManager()
{
	UnloadAllData();
}

void AccountManager :: LoadSectionGeneral(FileReader &fr, AccountData &ad, const char *debugFilename)
{
	char *NameBlock = fr.BlockToStringC(0, Case_Upper);

	if(strcmp(NameBlock, "ID") == 0)
		ad.ID = fr.BlockToIntC(1);
	else if(strcmp(NameBlock, "NAME") == 0)
		Util::SafeCopy(ad.Name, fr.BlockToStringC(1, 0), sizeof(ad.Name));
	else if(strcmp(NameBlock, "AUTH") == 0)
		ad.FillAuthorizationHash(fr.BlockToStringC(1, 0));
	else if(strcmp(NameBlock, "REGKEY") == 0)
		ad.FillRegistrationKey(fr.BlockToStringC(1, 0));
	else if(strcmp(NameBlock, "RECOVERYKEYS") == 0)
	{
		fr.BreakUntil("=", '=');
		ad.RecoveryKeys = fr.BlockToStringC(1, 0);
	}
	else if(strcmp(NameBlock, "SUSPENDTIME") == 0)
		ad.SuspendTimeSec = fr.BlockToULongC(1);
	else if(strcmp(NameBlock, "MAXCHARACTERS") == 0) {
		ad.MaxCharacters = fr.BlockToULongC(1);
		if(ad.MaxCharacters < AccountData::DEFAULT_CHARACTER_SLOTS) {
			ad.MaxCharacters = AccountData::DEFAULT_CHARACTER_SLOTS;
		}
	}
	else if(strcmp(fr.SecBuffer, "LASTLOGON") == 0)
	{
		strncpy(ad.LastLogOn, fr.BlockToStringC(1, 0), sizeof(ad.LastLogOn) - 1);
	}
	else if(strcmp(NameBlock, "CONSECUTIVEDAYSLOGGEDIN") == 0)
		ad.ConsecutiveDaysLoggedIn = fr.BlockToULongC(1);
	else if(strcmp(NameBlock, "CREDITS") == 0)
			ad.Credits = fr.BlockToULongC(1);
	else if(strcmp(NameBlock, "LASTLOGONTIME") == 0)
		ad.LastLogOnTimeSec = fr.BlockToULongC(1);
	else if(strcmp(NameBlock, "CREATEDTIME") == 0)
		ad.CreatedTimeSec = fr.BlockToULongC(1);
	else if(strcmp(NameBlock, "DELIVERYBOXSLOTS") == 0)
		ad.DeliveryBoxSlots = fr.BlockToIntC(1);
	else if(strcmp(NameBlock, "VETERANLEVEL") == 0)
		ad.VeteranLevel = fr.BlockToIntC(1);
	else if(strcmp(NameBlock, "VETERANIMPORTED") == 0)
		ad.VeteranImported = fr.BlockToBoolC(1);
	else if(strcmp(NameBlock, "SUSPENDDURATION") == 0)
		ad.SuspendDurationSec = fr.BlockToULongC(1);
	else if(strcmp(NameBlock, "CHARACTERS") == 0)
	{
		int NumChar = 0;
		int a;
		for(a = 0; a < AccountData::MAX_CHARACTER_SLOTS; a++)
		{
			if(fr.BlockLen[1 + a] > 0)
			{
				ad.CharacterSet[NumChar] = fr.BlockToIntC(1 + a);
				NumChar++;
			}
			else
			{
				break;
			}
		}
		if(NumChar > ad.MaxCharacters)
			ad.MaxCharacters = NumChar;
	}
	else if(strcmp(NameBlock, "PERMISSIONS") == 0)
	{
		int a;
		for(a = 1; a < fr.MULTIBLOCKCOUNT; a++)
		{
			if(fr.BlockLen[a] > 0)
			{
				if(ad.SetPermission(Perm_Account, fr.BlockToStringC(a, Case_Lower), true) == false)
					g_Log.AddMessageFormat("Warning: Unknown permission identifier [%s] in Accounts file.", fr.SecBuffer);
			}
			else
			{
				break;
			}
		}
	}
	else if(strcmp(NameBlock, "GROVENAME") == 0)
		ad.GroveName = fr.BlockToStringC(1, 0);
	else if(strcmp(NameBlock, "ACCOUNTQUEST") == 0)	{
		int qid = fr.BlockToIntC(1);
		if(ad.HasAccountCompletedQuest(qid)) {
			g_Logs.data->warn("Account %v has multiple account quests with same ID %v, ignoring", ad.ID, qid);
		}
		else {
			ad.AccountQuests.push_back(fr.BlockToIntC(1));
		}
	}
	else if(strcmp(NameBlock, "XCSRF") == 0)
		ad.SiteSession.xCSRF = fr.BlockToStringC(1, 0);
	else if(strcmp(NameBlock, "SESSIONID") == 0)
		ad.SiteSession.sessionID = fr.BlockToStringC(1, 0);
	else if(strcmp(NameBlock, "SESSIONNAME") == 0)
		ad.SiteSession.sessionName = fr.BlockToStringC(1, 0);
	else if(strcmp(NameBlock, "BUILD") == 0)
	{
		BuildPermissionArea bpa;
		bpa.ZoneID = fr.BlockToIntC(1);
		bpa.x1 = fr.BlockToIntC(2);
		bpa.y1 = fr.BlockToIntC(3);
		bpa.x2 = fr.BlockToIntC(4);
		bpa.y2 = fr.BlockToIntC(5);

		if(ad.HasBuildZone(bpa) == false)
			ad.BuildPermissionList.push_back(bpa);
	}
	else if(strcmp(NameBlock, "PREF") == 0)
	{
		//Slightly different format.
		//Preference names contain "." and values contain "=" and ","
		fr.BreakUntil("=,", ',');
		std::string name = fr.BlockToStringC(1, 0);
		std::string value = fr.BlockToStringC(2, 0);
		ad.preferenceList.SetPref(name.c_str(), value.c_str());
	}
	/* TODO:VAULT
	else if(strcmp(NameBlock, "CURRENTVAULTSIZE") == 0)
	{
		ad.CurrentVaultSize = fr.BlockToIntC(1);
	}
	*/
//	else if(strcmp(NameBlock, "BANK") == 0)
//	{
//		InventorySlot slot;
//		slot.CCSID = fr.BlockToIntC(1);
//		slot.IID = fr.BlockToIntC(2);
//		slot.count = fr.BlockToIntC(3);
//		slot.customLook = fr.BlockToIntC(4);
//		slot.bindStatus = fr.BlockToIntC(5);
//		if(slot.VerifyItemExist() == true)
//			ad.vaultInventory.push_back(slot);
//	}
//	else if(strcmp(NameBlock, "DELIVERY") == 0)
//	{
//		InventorySlot slot;
//		slot.CCSID = fr.BlockToIntC(1);
//		slot.IID = fr.BlockToIntC(2);
//		slot.count = fr.BlockToIntC(3);
//		slot.customLook = fr.BlockToIntC(4);
//		slot.bindStatus = fr.BlockToIntC(5);
//		if(slot.VerifyItemExist() == true)
//			ad.deliveryInventory.push_back(slot);
//	}
	else if(!ad.PlayerStats.LoadFromStream(fr)) {
		if(CheckSection_Inventory(fr, ad.inventory, debugFilename,  ad.Name, "Account") == -2) {
			g_Log.AddMessageFormat("Unknown identifier [%s] in file [%s]", NameBlock, debugFilename);
		}
	}
}

void AccountManager :: LoadSectionCharacterCache(FileReader &fr, AccountData &ad, const char *debugFilename)
{
	CharacterCacheEntry entry;
	while(fr.FileOpen() == true)
	{
		int r = fr.ReadLine();
		if(r > 0)
		{
			fr.BreakUntil("=", '=');
			fr.BlockToStringC(0, 0);
			if(strcmp(fr.SecBuffer, "[CACHEENTRY]") == 0)
				entry.Clear();
			else if(strcmp(fr.SecBuffer, "creatureDefID") == 0)
				entry.creatureDefID = fr.BlockToIntC(1);
			else if(strcmp(fr.SecBuffer, "level") == 0)
				entry.level = fr.BlockToIntC(1);
			else if(strcmp(fr.SecBuffer, "profession") == 0)
				entry.profession = fr.BlockToIntC(1);
			else if(strcmp(fr.SecBuffer, "display_name") == 0)
				entry.display_name = fr.BlockToStringC(1, 0);
			else if(strcmp(fr.SecBuffer, "appearance") == 0)
				entry.appearance = fr.BlockToStringC(1, 0);
			else if(strcmp(fr.SecBuffer, "eq_appearance") == 0)
				entry.eq_appearance = fr.BlockToStringC(1, 0);
			else if(strcmp(fr.SecBuffer, "[/CACHEENTRY]") == 0)
				ad.characterCache.AddEntry(entry);
			else if(strcmp(fr.SecBuffer, "[/CHARACTERCACHE]") == 0)
				return;
		}
	}
	g_Log.AddMessageFormat("Finished loading character cache");
}

void AccountManager :: LoadAccountFromStream(FileReader &fr, AccountData &ad, const char *debugFilename)
{
	bool curEntry = false;
	int r;
	while(fr.FileOpen())
	{
		long CurPos = ftell(fr.FileHandle[0]);
		r = fr.ReadLine();
		if(r > 0)
		{
			fr.MultiBreak("=,");
			fr.BlockToStringC(0, Case_Upper);
			if(strcmp(fr.SecBuffer, "[ENTRY]") == 0)
			{
				if(curEntry == true)
				{
					//Reset the position so it doesn't interfere with reading the next
					//entry
					fr.FilePos = CurPos;
					fseek(fr.FileHandle[0], CurPos, SEEK_SET);
					return;
				}
				else
					curEntry = true;
			}
			else if(strcmp(fr.SecBuffer, "[END]") == 0)
				return;
			else if(strcmp(fr.SecBuffer, "[CHARACTERCACHE]") == 0)
				LoadSectionCharacterCache(fr, ad, debugFilename);
			else
				LoadSectionGeneral(fr, ad, debugFilename);
		}
	}
	fr.CloseCurrent();
}

AccountQuickData * AccountManager :: GetAccountQuickDataByUsername(const char *username)
{
	for(size_t i = 0; i < accountQuickData.size(); i++)
		if(accountQuickData[i].mLoginName.compare(username) == 0)
			return &accountQuickData[i];
	return NULL;
}

AccountData * AccountManager :: GetValidLogin(const char *loginName, const char *loginAuth)
{
	//Takes the given login name and account strings, searching through the loaded
	//account list to find an entry that matches the given credentials.

	AccountQuickData *aqd = GetAccountQuickDataByUsername(loginName);
	if(aqd != NULL)
	{
		if(aqd->mLoginAuth.compare(loginAuth) == 0) {
			return FetchIndividualAccount(aqd->mID);
		}
	}
	return NULL;
}

void AccountManager :: ResolveCharacters(void)
{
	ACCOUNT_ITERATOR it;
	for(it = AccList.begin(); it != AccList.end(); ++it)
		it->ResolveCharacters(it->Name);
}

int AccountManager :: CreateAccount(const char *username, const char *password, const char *regKey, const char *grovename)
{
	if(username == NULL)  return ACCOUNT_SIZENAME;
	if(password == NULL)  return ACCOUNT_SIZEPASS;
	if(regKey == NULL)    return ACCOUNT_KEY;
	if(grovename == NULL) return ACCOUNT_SIZEGROVE;

	int keyIndex = GetRegistrationKey(regKey);
	if(keyIndex == -1) return ACCOUNT_KEY;

	if(strlen(username) < 3 || strlen(username) > sizeof(AccountData().Name) - 1)
		return ACCOUNT_SIZENAME;
	if(ValidString(username) == false)
		return ACCOUNT_INVNAME;

	if(FetchAccountByUsername(username) != NULL)
		return ACCOUNT_HASNAME;

	if(strlen(password) < 3 || strlen(password) > 32) // > sizeof(AccountData().AuthPass) - 1)
		return ACCOUNT_SIZEPASS;
	if(ValidString(password) == false)
		return ACCOUNT_INVPASS;

	if(strlen(grovename) < 3 || strlen(grovename) > 32)
		return ACCOUNT_SIZEGROVE;

	std::string adjustedGroveName = grovename;
	if(ValidGroveString(adjustedGroveName) == false)
		return ACCOUNT_INVGROVE;

	ZoneDefInfo *zoneDef = g_ZoneDefManager.GetPointerByGroveName(adjustedGroveName.c_str());
	if(zoneDef != NULL)
		return ACCOUNT_HASGROVE;


	//  *****  Everything verified.  Create the account.  *****
	AccountData newAccount;

	if(NextAccountID < (int)accountQuickData.size())
	{
		g_Log.AddMessageFormat("[WARNING] NextAccountID is lower than current total (%d of %d)", NextAccountID, accountQuickData.size());
		NextAccountID = accountQuickData.size();
	}
	newAccount.ID = NextAccountID++;
	newAccount.CreatedTimeSec = time(NULL);

	newAccount.SetPermission(Perm_Account, "regionchat", true);
	newAccount.SetPermission(Perm_Account, "forumpost", true);

#ifdef PRIVATE_USE_BUILD
	newAccount.SetPermission(Perm_Account, "debug", true);
	newAccount.SetPermission(Perm_Account, "tweakself", true);
	newAccount.SetPermission(Perm_Account, "itemgive", true);
	newAccount.SetPermission(Perm_Account, "fastload", true);
	newAccount.SetPermission(Perm_Account, "admin", true);
#endif

	//Assign username and registration key
	Util::SafeCopy(newAccount.Name, username, sizeof(newAccount.Name));
	newAccount.SetNewRegistrationKey(regKey);

	//Generate and assign the password hash
	newAccount.SetNewPassword(username, password);

	g_Log.AddMessageFormat("Created account: %s:%s", username, newAccount.AuthData);

	//Prepare the grove
	newAccount.GroveName = adjustedGroveName;
	BuildPermissionArea bp;
	bp.ZoneID = g_ZoneDefManager.CreateGrove(newAccount.ID, adjustedGroveName.c_str());
	bp.x1 = 0;
	bp.y1 = 0;
	bp.x2 = 3;
	bp.y2 = 3;
	newAccount.BuildPermissionList.push_back(bp);

	KeyList.erase(KeyList.begin() + keyIndex);
	KeyListChanges.AddChange();

	g_Log.AddMessageFormat("Account created [%s] with %d characters.", newAccount.Name, newAccount.GetCharacterCount());

	newAccount.PendingMinorUpdates++;  //Save at the next available opportunity
	AccList.push_back(newAccount);
	AppendQuickData(&newAccount);

	return ACCOUNT_SUCCESS;
}

int AccountManager :: CreateAccountFromService(const char *username)
{
	if(username == NULL)  return ACCOUNT_SIZENAME;

	if(strlen(username) < 3 || strlen(username) > sizeof(AccountData().Name) - 1)
		return ACCOUNT_SIZENAME;
	if(ValidString(username) == false)
		return ACCOUNT_INVNAME;

	if(FetchAccountByUsername(username) != NULL)
		return ACCOUNT_HASNAME;

	AccountData newAccount;

	if(NextAccountID < (int)accountQuickData.size())
	{
		g_Log.AddMessageFormat("[WARNING] NextAccountID is lower than current total (%d of %d)", NextAccountID, accountQuickData.size());
		NextAccountID = accountQuickData.size();
	}
	newAccount.ID = NextAccountID++;
	newAccount.CreatedTimeSec = time(NULL);
	Util::SafeCopy(newAccount.Name, username, sizeof(newAccount.Name));

	newAccount.SetPermission(Perm_Account, "regionchat", true);
	newAccount.SetPermission(Perm_Account, "forumpost", true);

#ifdef PRIVATE_USE_BUILD
	newAccount.SetPermission(Perm_Account, "debug", true);
	newAccount.SetPermission(Perm_Account, "tweakself", true);
	newAccount.SetPermission(Perm_Account, "itemgive", true);
	newAccount.SetPermission(Perm_Account, "fastload", true);
	newAccount.SetPermission(Perm_Account, "admin", true);
#endif

	g_Log.AddMessageFormat("Account created [%s] with %d characters.", newAccount.Name, newAccount.GetCharacterCount());

	newAccount.PendingMinorUpdates++;  //Save at the next available opportunity
	AccList.push_back(newAccount);
	AppendQuickData(&newAccount);

	return ACCOUNT_SUCCESS;
}

// Attempt to reset a password, given the supplied information from the password reset web form.
int AccountManager :: ResetPassword(const char *username, const char *newpassword, const char *regKey)
{
	if(username == NULL)  return ACCOUNT_SIZENAME;
	if(newpassword == NULL)  return ACCOUNT_SIZEPASS;
	if(regKey == NULL)    return ACCOUNT_KEY;

	if(strlen(newpassword) < 3 || strlen(newpassword) > 32) // > sizeof(AccountData().AuthPass) - 1)
		return ACCOUNT_SIZEPASS;
	if(ValidString(newpassword) == false)
		return ACCOUNT_INVPASS;
	
	AccountData *accPtr = FetchAccountByUsername(username);
	if(accPtr == NULL)
		return ACCOUNT_USERNOTFOUND;

	if(accPtr->HasPermission(Perm_Account, Permission_PasswordReset) == false)
		return ACCOUNT_PERMISSIONRESET;

	if(accPtr->MatchRegistrationKey(regKey) == false)
		return ACCOUNT_REGMISMATCH;

	//Set the new password, then update the quickdata entry.
	accPtr->SetNewPassword(username, newpassword);

	AccountQuickData *aqd = GetAccountQuickDataByUsername(username);
	if(aqd != NULL)
	{
		aqd->mLoginAuth = accPtr->AuthData;
		AccountQuickDataChanges.AddChange();
	}

	accPtr->SetPermission(Perm_Account, "passwordreset", false);
	accPtr->PendingMinorUpdates++;
	return ACCOUNT_PASSWORDRESETOK;
}

// Attempt to unlock an account, given the supplied information from the account recovery web form.
int AccountManager :: AccountRecover(const char *username, const char *keypass, const char *type)
{
	if(username == NULL)  return ACCOUNT_BADUSERNAME;
	if(type == NULL)    return ACCOUNT_BADREQUEST;

	AccountData *accPtr = FetchAccountByUsername(username);
	AccountQuickData *aqd = GetAccountQuickDataByUsername(username);
	if(accPtr == NULL || aqd == NULL)
		return ACCOUNT_USERNOTFOUND;

	if(accPtr->RecoveryKeys.size() == 0)
		return ACCOUNT_CANNOTRECOVER;

	if(strcmp(type, "key") == 0)
	{
		if(keypass == NULL) return ACCOUNT_BADKEY;
		if(strlen(keypass) == 0) return ACCOUNT_BADKEY;
		std::string key;
		AccountData::GenerateSaltedHash(keypass, key);
		if(accPtr->MatchRecoveryKey(type, key.c_str()) == true)
		{
			accPtr->FillRegistrationKey(keypass);
			aqd->mRegKey = keypass;

			accPtr->RecoveryKeys.clear();

			accPtr->PendingMinorUpdates++;
			AccountQuickDataChanges.AddChange();

			return ACCOUNT_SUCCESSRECOVER;
		}
		else
		{
			return ACCOUNT_REJECTED;
		}
	}
	else if(strcmp(type, "password") == 0)
	{
		if(keypass == NULL) return ACCOUNT_BADPASSWORD;
		if(strlen(keypass) == 0) return ACCOUNT_BADPASSWORD;

		std::string clientPass;
		std::string serverPass;
		accPtr->GenerateClientPasswordHash(username, keypass, clientPass);
		AccountData::GenerateSaltedHash(clientPass.c_str(), serverPass);

		if(accPtr->MatchRecoveryKey(type, serverPass.c_str()) == true)
		{
			accPtr->FillAuthorizationHash(serverPass.c_str());
			aqd->mLoginAuth = serverPass;

			accPtr->RecoveryKeys.clear();

			accPtr->PendingMinorUpdates++;
			AccountQuickDataChanges.AddChange();

			return ACCOUNT_SUCCESSRECOVER;
		}
		else
		{
			return ACCOUNT_REJECTED;
		}
	}
	else
	{
		return ACCOUNT_BADREQUEST;
	}
}

void AccountManager :: LoadKeyList(const char *fileName)
{
	KeyFileName = fileName;
	LoadStringsFile(fileName, KeyList);
}

int AccountManager :: GetRegistrationKey(const char *authKey)
{
	for(size_t i = 0; i < KeyList.size(); i++)
		if(KeyList[i].compare(authKey) == 0)
			return i;
	return -1;
}

bool AccountManager :: ValidString(const char *str)
{
	size_t len = strlen(str);
	for(size_t i = 0; i < len; i++)
	{
		if(str[i] <= 32)
			return false;
		if(str[i] >= 127)
			return false;
		if(str[i] == ',' || str[i] == ';' || str[i] == '|' || str[i] == '&')
			return false;
	}
	return true;
}

bool AccountManager :: ValidGroveString(std::string &nameToAdjust)
{
	for(size_t i = 0; i < nameToAdjust.size(); i++)
	{
		char c = nameToAdjust[i];
		if(c >= 'A' && c <= 'Z')
			nameToAdjust[i] += 32;
		else if(c < 'a' || c > 'z')
			return false;
	}
	return true;
}


AccessToken* AccountManager :: GetToken(std::string token)
{
	cs.Enter("AccountManager::GetToken");
	AccessToken *t = Tokens[token];
	if(t != NULL) {
		if(t->uses != -1) {
			if(t->uses < 1) {
				Tokens.erase(Tokens.find(token));
				delete t;
				cs.Leave();
				return NULL;
			}
			t->uses--;
		}
		if( g_ServerTime < t->expire) {
			cs.Leave();
			return t;
		}
		Tokens.erase(Tokens.find(token));
		delete t;

	}
	cs.Leave();
	return NULL;
}

std::string AccountManager :: GenerateToken(int accountID, unsigned long ttl, int tokenType, int uses)
{
	std::string token = Util::RandomHexStr(32);
	AccessToken *t = new AccessToken();
	t->accountID = accountID;
	t->expire = g_ServerTime + ttl;
	t->tokenType = tokenType;
	t->token = token;
	t->uses = uses;
	cs.Enter("AccountManager::GenerateToken");
	Tokens[token] = t;
	cs.Leave();
	return token;
}

AccountData * AccountManager :: FetchAccountByUsername(const char *username)
{
	ACCOUNT_ITERATOR it;
	for(it = AccList.begin(); it != AccList.end(); ++it)
		if(strcmp(it->Name, username) == 0)
			return &*it;

	for(size_t i = 0; i < accountQuickData.size(); i++)
		if(accountQuickData[i].mLoginName.compare(username) == 0)
			return FetchIndividualAccount(accountQuickData[i].mID);
	return NULL;
}

const char * AccountManager :: GetErrorMessage(int message)
{
	switch(message)
	{
	case ACCOUNT_SUCCESS: return "Account creation was successful.";
	case ACCOUNT_KEY: return "Missing or invalid registration key.";
	case ACCOUNT_SIZENAME: return "The username must contain between 3-32 characters.";
	case ACCOUNT_INVNAME: return "The username contains invalid characters.";
	case ACCOUNT_HASNAME: return "That username already exists.";
	case ACCOUNT_SIZEPASS: return "The password must contain between 3-32 characters.";
	case ACCOUNT_INVPASS: return "The password contains invalid characters.";
	case ACCOUNT_SIZEGROVE: return "The grove name must contain between 3-32 characters.";
	case ACCOUNT_INVGROVE: return "The grove name contains invalid characters.";
	case ACCOUNT_HASGROVE: return "That grove name already exists.";
	case ACCOUNT_REGMISMATCH: return "The registration key does not match the one that created the account.";
	case ACCOUNT_PASSWORDRESETOK: return "Password was successfully reset.";
	case ACCOUNT_USERNOTFOUND: return "The username was not found.";
	case ACCOUNT_PERMISSIONRESET: return "The account must be approved for a password reset.";

	case ACCOUNT_BADUSERNAME:    return "Username was missing or not supplied.";
	case ACCOUNT_BADKEY:         return "Registration key was missing or not supplied.";
	case ACCOUNT_BADPASSWORD:    return "Password was missing or not supplied.";
	case ACCOUNT_REJECTED:       return "Account recover failed, information does not match.";
	case ACCOUNT_SUCCESSRECOVER: return "The account was recovered successfully.";
	case ACCOUNT_BADREQUEST:     return "The required information was malformed or incomplete.";
	case ACCOUNT_CANNOTRECOVER:  return "This account cannot be recovered.  If recovered before, it cannot be recovered again.";
	default:
		return "Unknown error.";
	}
}

const char * AccountManager :: GetCharacterErrorMessage(int message)
{
	switch(message)
	{
	case CHARACTER_SUCCESS: return "OK";
	case CHARACTER_INVQUERY: return "Invalid or malformed query.";
	case CHARACTER_NOSLOTS: return "No free character slots.";
	case CHARACTER_FIRSTINV: return "Invalid first name.";
	case CHARACTER_FIRSTSHORT: return "First name is too short.";
	case CHARACTER_FIRSTLONG: return "First name is too long.";
	case CHARACTER_LASTINV: return "Invalid last name.";
	case CHARACTER_LASTSHORT: return "Last name is too short.";
	case CHARACTER_LASTLONG: return "Last name is too long.";
	case CHARACTER_NAMEEXIST: return "A character with that name already exists.";
	default:
		return "Unknown error.";
	}
}

int AccountManager :: CheckAutoSave(bool force)
{
	int saveOps = 0;
	if(KeyListChanges.PendingChanges > 0)
	{
		if(force == true || KeyListChanges.IsLastChangeSince(5000))
		{
			saveOps++;
			SaveKeyListChanges();
		}
	}

	
	if(UsedCharacterNames.HasChanged() == true)
	{
		if(force == true || UsedCharacterNames.mChanges.IsLastChangeSince(5000))
		{
			saveOps++;
			SaveUsedNameListChanges();
		}
	}

	if(AccountQuickDataChanges.PendingChanges > 0)
	{
		if(force == true || AccountQuickDataChanges.IsLastChangeSince(5000))
		{
			saveOps++;
			SaveQuickData();
		}
	}
	return saveOps;
}

int AccountManager :: HasPendingMinorUpdates(void)
{
	int pendingCount = 0;
	ACCOUNT_ITERATOR it;
	for(it = AccList.begin(); it != AccList.end(); ++it)
		pendingCount += it->PendingMinorUpdates;

	return pendingCount;
}

void AccountManager :: SaveKeyListChanges(void)
{
	if(KeyListChanges.PendingChanges == 0)
		return;

	//Enter thread before attempting to open the file, otherwise
	//a thread deadlock will wipe the file without writing new data.
	cs.Enter("AccountManager::SaveKeyListChanges");

	FILE *output = Util::OpenSaveFile(KeyFileName.c_str());
	if(output == NULL)
	{
		g_Logs.data->error("Failed to open file for writing: [%v]", KeyFileName.c_str());
		cs.Leave();
		return;
	}

	Util::WriteAutoSaveHeader(output);

	std::vector<std::string>::iterator it;
	for(it = KeyList.begin(); it != KeyList.end(); ++it)
		fprintf(output, "%s\r\n", it->c_str());

	fclose(output);
	KeyListChanges.ClearPending();
	cs.Leave();

	g_Logs.data->info("Saved registration key changes.");
}

void AccountManager :: SaveUsedNameListChanges(void)
{
	if(UsedCharacterNames.HasChanged() == false)
		return;

	//Enter thread before attempting to open the file, otherwise
	//a thread deadlock will wipe the file without writing new data.
	cs.Enter("AccountManager::SaveUsedNameListChanges");

	FILE *output = Util::OpenSaveFile(UsedListFileName.c_str());
	if(output == NULL)
	{
		g_Logs.data->error("Failed to open file for writing: [%v]", UsedListFileName.c_str());
		cs.Leave();
		return;
	}

	Util::WriteAutoSaveHeader(output);

	/*
	USEDCHAR_VECTOR::iterator it;
	for(it = UsedCharacterNames.begin(); it != UsedCharacterNames.end(); ++it)
		fprintf(output, "%d=%s\r\n", it->first, it->second.c_str());
	*/
	UsedNameDatabase::ITERATOR it;
	UsedNameDatabase::CONTAINER_REF data = UsedCharacterNames.GetData();
	for(it = data.begin(); it != data.end(); ++it)
		fprintf(output, "%d=%s\r\n", it->first, it->second.c_str());

	fclose(output);
	UsedCharacterNames.mChanges.ClearPending();
	cs.Leave();

	g_Logs.data->info("Saved used character list changes.");
}

bool AccountManager :: ValidCharacterName(const std::string &name)
{
	for(size_t i = 0; i < name.size(); i++)
	{
		bool valid = false;
		if(name[i] >= 'A' && name[i] <= 'Z')
			valid = true;
		if(name[i] >= 'a' && name[i] <= 'z')
			valid = true;
		if(valid == false)
			return false;
	}
	return true;
}

int AccountManager :: ValidateNameParts(const std::string &first, const std::string &last)
{
	if(first.size() == 0) return CHARACTER_FIRSTSHORT;
	if(first.size() > 16) return CHARACTER_FIRSTLONG;
	if(last.size() == 0)	return CHARACTER_LASTSHORT;
	if(last.size() > 16) return CHARACTER_LASTLONG;

	if(ValidCharacterName(first) == 0)
		return CHARACTER_FIRSTINV;

	if(ValidCharacterName(last) == 0)
		return CHARACTER_LASTINV;

	char buffer[3072];
	sprintf(buffer, "%s %s", first.c_str(), last.c_str());
	//Check character name
	if(HasUsedCharacterName(buffer) == true)
		return CHARACTER_NAMEEXIST;

	return CHARACTER_SUCCESS;
}

int AccountManager :: CreateCharacter(STRINGLIST &args, AccountData *accPtr, CharacterData &newChar)
{
	// Safeguard to make sure the query is valid.
	// Variable elements begin at index [11]. All previous elements must exist.
	if(args.size() <= 12)
		return CHARACTER_INVQUERY;

	int r = accPtr->GetFreeCharacterSlot();
	if(r >= 0)
	{
		int rr = ValidateNameParts(args[0], args[1]);
		if(rr != CHARACTER_SUCCESS) {
			return rr;
		}

		// The first name may only be sage if the account has sage permissons
		if(Util::CaseInsensitiveStringCompare(args[0], "Sage") && !accPtr->HasPermission(Perm_Account, Permission_Sage)) {
			return CHARACTER_FIRSTINV;
		}

		int newID = GetNewCharacterID();
		SessionVarsChangeData.AddChange();
		accPtr->CharacterSet[r] = newID;

		newChar.CopyFrom(*g_CharacterManager.GetDefaultCharacter());
		newChar.CreatedTimeSec = time(NULL);
		newChar.cdef.CreatureDefID = newID;
		newChar.cdef.DefHints = 1;
		newChar.pendingChanges = 1;
		newChar.SetExpireTime();

		//Character name is in buffer, from above
		char buffer[3072];
		sprintf(buffer, "%s %s", args[0].c_str(), args[1].c_str());
		Util::SafeCopy(newChar.cdef.css.display_name, buffer, sizeof(newChar.cdef.css.display_name));

		static const char *RaceNames[4] = {"Knight", "Rogue", "Mage", "Druid"};
		int prof = 0;
		for(int a = 0; a < 4; a++)
		{
			if(args[2].compare(RaceNames[a]) == 0)
			{
				prof = a;
				break;
			}
		}
		newChar.cdef.css.profession = prof + 1;
		newChar.cdef.css.level = 1;
		newChar.UpdateBaseStats(NULL, true);
		newChar.cdef.css.health = newChar.cdef.css.constitution * HealthConModifier;
		newChar.cdef.css.will = 10;
		newChar.cdef.css.will_regen = 1.0F;
		newChar.cdef.css.might = 10;
		newChar.cdef.css.might_regen = 1.0F;

		newChar.AbilityRespec(NULL);

		int wpos = 0;
		wpos += sprintf(&buffer[wpos], "c2:{");
		wpos += sprintf(&buffer[wpos], "[\"h\"]=%s,", args[6].c_str());
		wpos += sprintf(&buffer[wpos], "[\"b\"]=\"%s\",", args[5].c_str());
		wpos += sprintf(&buffer[wpos], "[\"r\"]=\"%s\",", args[3].c_str());
		wpos += sprintf(&buffer[wpos], "[\"g\"]=\"%s\",", args[4].c_str());

		// For some reason the client is set to default as 0.85, but the
		// size slider ranges from 0.9 to 1.1
		if(args[7].compare("0.85") == 0)
			args[7] = "1.0";
		wpos += sprintf(&buffer[wpos], "[\"sz\"]=\"%s\",", args[7].c_str());

		wpos += sprintf(&buffer[wpos], "[\"sk\"]={");
		for(size_t i = 11; i < args.size(); i+=2)
			wpos += sprintf(&buffer[wpos], "[\"%s\"]=\"%s\",", args[i].c_str(), args[i + 1].c_str());

		wpos--;  //Step back to remove the trailing comma

		wpos += sprintf(&buffer[wpos], "}}");  //Close both the ["sk"] and "c2:" tables.

		//g_Log.AddMessageFormat("Creating string: [%s]", buffer);

		//strncpy(newChar.cdef.css.appearance, buffer, sizeof(newChar.cdef.css.appearance) - 1);
		newChar.cdef.css.SetAppearance(buffer);

		//Set the starting items.
		int shirtIndex = atoi(args[8].c_str());
		int pantsIndex = atoi(args[9].c_str());
		int bootsIndex = atoi(args[10].c_str());


		//Banded Tunic, Leather Tunic, Cloth Vest, Wool Vestment, Twill Tunic
		static const int shirtArray[5] = { 3019, 1844, 2810, 3160, 2107 };

		//Banded Leggings, Leather Pants, Cloth Wrap, Wool Leg Wraps, Twill Pants
		static const int pantsArray[5] = { 3008, 3158, 1980, 3161, 2442 };

		//Banded Boots, Leather Boots, Cloth Shoes, Wool Shoes, Twill Boots
		static const int bootsArray[5] = { 2831, 3159, 2108, 3162, 2898 };

		//Starting Druid equipment.
		//{[0]=143606,[2]=143609,[6]=3160,[10]=3161,[11]=3162}
		InventoryManager &inventory = newChar.inventory;
		InventorySlot item;

		item.CCSID = inventory.GetCCSID(EQ_CONTAINER, ItemEquipSlot::ARMOR_CHEST);
		item.IID = shirtArray[shirtIndex];
		inventory.containerList[EQ_CONTAINER].push_back(item);

		item.CCSID = inventory.GetCCSID(EQ_CONTAINER, ItemEquipSlot::ARMOR_LEGS);
		item.IID = pantsArray[pantsIndex];
		inventory.containerList[EQ_CONTAINER].push_back(item);

		item.CCSID = inventory.GetCCSID(EQ_CONTAINER, ItemEquipSlot::ARMOR_FEET);
		item.IID = bootsArray[bootsIndex];
		inventory.containerList[EQ_CONTAINER].push_back(item);

		//Knight: Sword + Shield
		//Rogue: Dagger + Dagger
		//Mage: Wand
		//Druid: Bow

		if(prof == 0)  //Knight = 141760:Sword, 3163:Banded Buckler
		{
			item.CCSID = inventory.GetCCSID(EQ_CONTAINER, ItemEquipSlot::WEAPON_MAIN_HAND);
			item.IID = 141760;
			inventory.containerList[EQ_CONTAINER].push_back(item);

			item.CCSID = inventory.GetCCSID(EQ_CONTAINER, ItemEquipSlot::WEAPON_OFF_HAND);
			item.IID = 3163;
			inventory.containerList[EQ_CONTAINER].push_back(item);
		}
		else if(prof == 1)  //Rogue = 141763:Short Blade, 141764:Small Dagger
		{
			item.CCSID = inventory.GetCCSID(EQ_CONTAINER, ItemEquipSlot::WEAPON_MAIN_HAND);
			item.IID = 141763;
			inventory.containerList[EQ_CONTAINER].push_back(item);

			item.CCSID = inventory.GetCCSID(EQ_CONTAINER, ItemEquipSlot::WEAPON_OFF_HAND);
			item.IID = 141764;
			inventory.containerList[EQ_CONTAINER].push_back(item);
		}
		else if(prof == 2)  //Mage = 141765:Wand
		{
			item.CCSID = inventory.GetCCSID(EQ_CONTAINER, ItemEquipSlot::WEAPON_RANGED);
			item.IID = 141765;
			inventory.containerList[EQ_CONTAINER].push_back(item);
		}
		else if(prof == 3)  //Druid = 143609:Bow
		{
			item.CCSID = inventory.GetCCSID(EQ_CONTAINER, ItemEquipSlot::WEAPON_RANGED);
			item.IID = 143609;
			inventory.containerList[EQ_CONTAINER].push_back(item);
		}

		newChar.UpdateEqAppearance();
		newChar.OnCharacterCreation();
		newChar.OnFinishedLoading();
		newChar.AccountID = accPtr->ID;

		newChar.bindReturnPoint[0] = 5822;
		newChar.bindReturnPoint[1] = 684;
		newChar.bindReturnPoint[2] = 5877;
		newChar.bindReturnPoint[3] = 59;
		newChar.cdef.css.translocate_destination = "Mushroom Isle";

		g_CharacterManager.AddExternalCharacter(newChar.cdef.CreatureDefID, newChar);
		AddUsedCharacterName(newChar.cdef.CreatureDefID, newChar.cdef.css.display_name);
		
		CharacterCacheEntry entry;
		entry.Clear();
		entry.creatureDefID = newChar.cdef.CreatureDefID;
		entry.level = newChar.cdef.css.level;
		entry.profession = newChar.cdef.css.profession;
		entry.display_name = newChar.cdef.css.display_name;
		entry.appearance = newChar.cdef.css.appearance;
		entry.eq_appearance = newChar.cdef.css.eq_appearance;
		accPtr->characterCache.AddEntry(entry);


		accPtr->PendingMinorUpdates++;


/*[Sim:0]   [0]=Test
[Sim:0]   [1]=Character
[Sim:0]   [2]=Druid
[Sim:0]   [3]=g
[Sim:0]   [4]=m
[Sim:0]   [5]=n
[Sim:0]   [6]=0
[Sim:0]   [7]=0.85
[Sim:0]   [8]=2
[Sim:0]   [9]=1
[Sim:0]   [10]=0
[Sim:0]   [11]=hands_feet
[Sim:0]   [12]=8e95a7
[Sim:0]   [13]=inner_ear
[Sim:0]   [14]=d8c0b6
[Sim:0]   [15]=nails
[Sim:0]   [16]=56514a
[Sim:0]   [17]=mask
[Sim:0]   [18]=9891ac
[Sim:0]   [19]=base
[Sim:0]   [20]=8d86a1
[Sim:0]   [21]=head_highlight
[Sim:0]   [22]=d4a86b
[Sim:0]   [23]=eye
[Sim:0]   [24]=71a6ac
[Sim:0]   [25]=eye_white
[Sim:0]   [26]=b1a5a5
[Sim:0]   [27]=nose
[Sim:0]   [28]=7e7890
[Sim:0]   [29]=chest
[Sim:0]   [30]=b9aaa0
*/

	}
	else
	{
		return CHARACTER_NOSLOTS;
	}
	return r; //return the character index
}

int AccountManager :: GetNewCharacterID(void)
{
	int retval = NextCharacterID;
	NextCharacterID += CHARACTER_ID_INCREMENT;
	return retval;
}

bool AccountManager :: HasUsedCharacterName(const char *characterName)
{
	return UsedCharacterNames.HasName(characterName);
	/*
	USEDCHAR_VECTOR::iterator it;
	for(it = UsedCharacterNames.begin(); it != UsedCharacterNames.end(); ++it)
		if(it->second.compare(characterName) == 0)
			return it - UsedCharacterNames.begin();

	return -1;
	*/
}

int AccountManager :: GetCDefFromCharacterName(const char *characterName)
{
	return UsedCharacterNames.GetIDByName(characterName);
	/*
	USEDCHAR_VECTOR::iterator it;
	for(it = UsedCharacterNames.begin(); it != UsedCharacterNames.end(); ++it)
		if(it->second.compare(characterName) == 0)
			return it->first;

	return -1;
	*/
}

const char* AccountManager :: GetCharacterNameFromCDef(int CDefID)
{
	return UsedCharacterNames.GetNameByID(CDefID);
}

void AccountManager :: AddUsedCharacterName(int CDefID, const char *characterName)
{
	if(HasUsedCharacterName(characterName) == false)
	{
		UsedCharacterNames.Add(CDefID, characterName);
		//UsedCharacterNames.push_back(USEDCHAR_PAIR(CDefID, characterName));
		//UsedNameListChanges.AddChange();
	}

	/*
	int i = HasUsedCharacterName(characterName);
	if(i == -1)
	{
		UsedCharacterNames.push_back(USEDCHAR_PAIR(CDefID, characterName));
		UsedNameListChanges.AddChange();
	}
	*/
}

void AccountManager :: LoadUsedNameList(const char *fileName)
{
	UsedListFileName = fileName;
	FileReader lfr;
	if(lfr.OpenText(fileName) != Err_OK)
	{
		g_Logs.data->error("Could not open file [%v]", fileName);
		return;
	}
	lfr.CommentStyle = Comment_Semi;
	while(lfr.FileOpen() == true)
	{
		lfr.ReadLine();
		int r = lfr.SingleBreak("=");
		if(r >= 2)
		{
			//Can't mix both Block() calls in the same statement since they share a data return buffer.
			int CDefID = lfr.BlockToInt(0);
			UsedCharacterNames.Add(CDefID, lfr.BlockToString(1), true);
			//UsedCharacterNames.push_back(USEDCHAR_PAIR(CDefID, lfr.BlockToString(1)));
		}
	}
	g_Logs.data->info("Loaded %v Used Names.", UsedCharacterNames.GetDataCount());
	lfr.CloseCurrent();
}

void AccountManager :: DeleteCharacter(int index, AccountData *accPtr)
{
	if(index < 0 || index >= accPtr->MAX_CHARACTER_SLOTS)
		return;

	int CDefID = accPtr->CharacterSet[index];
	if(CDefID == 0)
		return;

	cs.Enter("AccountManager::DeleteCharacter");

	for(int i = AccountData::MAX_CHARACTER_SLOTS - 2; i >= index; i--)
		accPtr->CharacterSet[i] = accPtr->CharacterSet[i + 1];
	accPtr->CharacterSet[AccountData::MAX_CHARACTER_SLOTS - 1] = 0;
	accPtr->characterCache.RemoveCharacter(CDefID);
	accPtr->PendingMinorUpdates++;

	g_Log.AddMessageFormat("[CHARACTER] Deleted character ID:%d", CDefID);

	char sourceBuf[256];
	char destBuf[256];
	Util::SafeFormat(sourceBuf, sizeof(sourceBuf), "Characters\\%d.txt", CDefID);
	Util::SafeFormat(destBuf, sizeof(destBuf), "Deleted\\%d.txt", CDefID);
	Platform::FixPaths(sourceBuf);
	Platform::FixPaths(destBuf);
	Platform::MakeDirectory("Deleted");
	Platform::FileCopy(sourceBuf, destBuf);
	remove(sourceBuf);

	RemoveUsedCharacterName(CDefID);
	cs.Leave();
}

void AccountManager :: RemoveUsedCharacterName(int CDefID)
{
	UsedCharacterNames.Remove(CDefID);

	/*
	USEDCHAR_VECTOR::iterator it;

	for(it = UsedCharacterNames.begin(); it != UsedCharacterNames.end(); ++it)
	{
		if(it->first == CDefID)
		{
			UsedCharacterNames.erase(it);
			break;
		}
	}
	UsedNameListChanges.AddChange();
	*/
}

void AccountManager :: AppendQuickData(AccountData *account)
{
	AccountQuickData object;
	object.mID = account->ID;
	object.mLoginName = account->Name;
	object.mLoginAuth = account->AuthData;
	object.mRegKey = account->RegKey;
	object.mGroveName = account->GroveName;

	accountQuickData.push_back(object);
	AccountQuickDataChanges.AddChange();
}

bool AccountManager :: SaveQuickData(void)
{
	char buffer[256];
	Platform::GenerateFilePath(buffer, "Dynamic", "AccountList.txt");
	FILE *output = Util::OpenSaveFile(buffer);
	if(output == NULL)
		return false;

	//Note: the registration key technically isn't necessary, but it's very handy to include
	//since it allows easy administrative lookups with a simple text find to match with its
	//account owner.  Sort of like how the character names file is handy to look up matching
	//character files.
	for(size_t i = 0; i < accountQuickData.size(); i++)
	{
		fprintf(output, "%d;%s;%s;%s;%s\r\n",
			accountQuickData[i].mID,
			accountQuickData[i].mLoginName.c_str(),
			accountQuickData[i].mLoginAuth.c_str(),
			accountQuickData[i].mRegKey.c_str(),
			accountQuickData[i].mGroveName.c_str());
	}
	fpos_t pos;
	fgetpos(output, &pos);

	fflush(output);
	fclose(output);
	AccountQuickDataChanges.ClearPending();
	return true;
}

void AccountManager :: LoadQuickData(void)
{
	char buffer[256];
	Platform::GenerateFilePath(buffer, "Dynamic", "AccountList.txt");
	FileReader lfr;
	if(lfr.OpenText(buffer) != Err_OK)
	{
		g_Log.AddMessageFormat("[ERROR] Unable to open file: %s", buffer);
		return;
	}
	AccountQuickData data;
	int highestID = 0;
	int line = 0;
	while(lfr.FileOpen() == true)
	{
		lfr.ReadLine();
		line++;
		int r = lfr.MultiBreak(";");
		if(r >= 2)
		{
			data.mID = lfr.BlockToIntC(0);
			data.mLoginName = lfr.BlockToStringC(1, 0);
			if(r == 5) {
				data.mLoginAuth = lfr.BlockToStringC(2, 0);
				data.mRegKey = lfr.BlockToStringC(3, 0);
				data.mGroveName = lfr.BlockToStringC(4, 0);
			}

			if(data.mID > highestID)
				highestID = data.mID;

			accountQuickData.push_back(data);
			data.Clear();
		}
		else if(r != 0) {
			g_Log.AddMessageFormat("[WARNING] AccountList.txt invalid data on line %d (has %d elements)", line, r);
		}
	}
	
	//This is to fix any discrepancies with server data, to prevent a faulty or missing session value
	//from overwriting new accounts.
	highestID++; //The next available ID needs to be 1 past the current highest.
	if(highestID > NextAccountID)
	{
		g_Log.AddMessageFormat("[WARNING] LoadQuickData() NextAccountID incorrect (current: %d, highest: %d)", NextAccountID, highestID);
		NextAccountID = highestID;
	}
	lfr.CloseCurrent();
}

AccountData * AccountManager :: GetActiveAccountByID(int accountID)
{
	ACCOUNT_ITERATOR it;
	for(it = AccList.begin(); it != AccList.end(); ++it)
		if(it->ID == accountID)
			return &*it;
	return NULL;
}

AccountData * AccountManager :: FetchIndividualAccount(int accountID)
{
	AccountData *search = GetActiveAccountByID(accountID);
	if(search != NULL)
		return search;

	//Not found, load it.
	return LoadAccountID(accountID);
}

const char * AccountManager :: GetIndividualFilename(char *buffer, int bufsize, int accountID)
{
	Util::SafeFormat(buffer, bufsize, "Accounts\\%08d.txt", accountID);
	Platform::FixPaths(buffer);
	return buffer;
}

AccountData * AccountManager :: LoadAccountID(int accountID)
{
	char filename[48];
	GetIndividualFilename(filename, sizeof(filename), accountID);

	FileReader lfr;
	if(lfr.OpenText(filename) != Err_OK)
	{
		g_Log.AddMessageFormat("[ERROR] Failed to open account: %s", filename);
		return NULL;
	}

	AccountData accData;
	lfr.CommentStyle = Comment_Semi;
	LoadAccountFromStream(lfr, accData, filename);
	lfr.CloseCurrent();

	if(accData.ID != 0)
	{
		g_Log.AddMessageFormat("Loaded account file: %s", filename);
		AccList.push_back(accData);
	}
	else
	{
		g_Log.AddMessageFormat("[ERROR] Account file possibly damaged: %s", filename);
		return NULL;
	}

	if(AccList.size() > 0)
		if(AccList.back().ID == accountID)
			return &AccList.back();

	g_Log.AddMessageFormat("[ERROR] Failed to retrieve account: %d", accountID);
	return NULL;
}

void AccountManager :: LoadAllData(void)
{
	char filebuf[256];
	LoadQuickData();
	LoadKeyList(Platform::GenerateFilePath(filebuf, "Dynamic", "RegistrationKeys.txt"));
	LoadUsedNameList(Platform::GenerateFilePath(filebuf, "Dynamic", "UsedNames.txt"));
}

void AccountManager :: UnloadAllData(void)
{
	CheckAutoSave(true);

	AccList.clear();
	KeyList.clear();
	accountQuickData.clear();
	AccountQuickDataChanges.ClearPending();
}

/* Saves an account to an individual file.  The file is opened according to a name
determined by ID, the contents are written, and the file is closed. */
void AccountManager :: SaveIndividualAccount(AccountData *account)
{
	char buffer[256];
	GetIndividualFilename(buffer, sizeof(buffer), account->ID);
	FILE *output = fopen(buffer, "wb");
	if(output == NULL)
	{
		g_Log.AddMessageFormat("[ERROR] SaveAccountToStream could not open: %s", buffer);
		return;
	}
	account->SaveToStream(output);
	fflush(output);
	fclose(output);
}

void AccountManager :: RunUpdateCycle(bool force)
{
	if(TimerGeneralUpdate.ReadyWithUpdate(GENERAL_UPDATE_FREQUENCY) == false && force == false)
		return;

	ACCOUNT_ITERATOR it;
	it = AccList.begin();
	while(it != AccList.end())
	{
		if(it->PendingMinorUpdates > 0)
		{
			SaveIndividualAccount(&*it);
			it->PendingMinorUpdates = 0;
			g_Log.AddMessageFormat("[ACCOUNT] Saved: %d", it->ID);
		}

		if(it->QualifyGarbage(force) == true)
		{
			g_Log.AddMessageFormat("[ACCOUNT] Unloading: %d", it->ID);
			AccList.erase(it++);
		}
		else
			++it;
	}
}

void AccountManager :: ImportKeys(void)
{
	STRINGLIST importList;
	LoadStringsFile("ImportKeys.txt", importList);
	int fail = 0;
	int succeed = 0;
	for(size_t i = 0; i < importList.size(); i++)
	{
		bool bFound = false;
		for(size_t s = 0; s < KeyList.size(); s++)
		{
			if(KeyList[s].compare(importList[i]) == 0)
			{
				bFound = true;
				break;
			}
		}
		for(size_t s = 0; s < accountQuickData.size(); s++)
		{
			if(accountQuickData[s].mRegKey.compare(importList[i]) == 0)
			{
				bFound = true;
				break;
			}
		}
		if(bFound == false)
		{
			KeyList.push_back(importList[i]);
			succeed++;
		}
		else
		{
			g_Log.AddMessageFormat("[KEY] import collision: %s", importList[i].c_str());
			fail++;
		}
	}
	KeyListChanges.AddChange();
	g_Log.AddMessageFormat("[KEY] Success: %d, Failed: %d", succeed, fail);
}

bool AccountManager :: AcceptingLogins(void)
{

#ifdef PRIVATE_USE_BUILD
	if(AccList.size() < MAX_CONCURRENT_LOGINS)
		return true;
	return false;
#endif

	return true;
}


CharacterCacheEntry* CharacterCacheManager :: GetCacheCharacter(int cdefID)
{
	//Searches the cache for a character, but will not load it if it doesn't exist.
	for(size_t i = 0; i < cacheData.size(); i++)
		if(cacheData[i].creatureDefID == cdefID)
			return &cacheData[i];
	return NULL;
}

CharacterCacheEntry* CharacterCacheManager :: ForceGetCharacter(int cdefID)
{
	//Search the cache for a character. If it doesn't exist, load the character file.
	CharacterCacheEntry *cce = GetCacheCharacter(cdefID);
	if(cce == NULL)
	{
		g_Log.AddMessageFormat("Loading character entry [%d] into cache", cdefID);
		CharacterData *charData = g_CharacterManager.RequestCharacter(cdefID, true);
		if(charData == NULL)
			charData = g_CharacterManager.GetDefaultCharacter();
		if(charData != NULL)
			cce = UpdateCharacter(charData);
	}
	else
		g_Log.AddMessageFormat("Retrieved character entry [%d] from cache", cdefID);
	return cce;
}

CharacterCacheEntry* CharacterCacheManager :: UpdateCharacter(CharacterData *charData)
{
	if(charData == NULL)
		return NULL;

	CharacterCacheEntry *entry = NULL;
	entry = GetCacheCharacter(charData->cdef.CreatureDefID);
	if(entry == NULL)
	{
		size_t osize = cacheData.size();
		cacheData.push_back(CharacterCacheEntry());
		size_t nsize = cacheData.size();
		if(nsize > osize)  //Verify it was added to retrieve its pointer.
			entry = &cacheData.back();
	}

	if(entry == NULL)
	{
		g_Log.AddMessageFormat("[ERROR] UpdateCharacter() failed");
		return NULL;
	}

	entry->creatureDefID = charData->cdef.CreatureDefID;
	entry->level = charData->cdef.css.level;
	entry->profession = charData->cdef.css.profession;
	entry->display_name = charData->cdef.css.display_name;
	entry->appearance = charData->cdef.css.appearance;
	entry->eq_appearance = charData->cdef.css.eq_appearance;
	return entry;
}

void CharacterCacheManager :: RemoveCharacter(int cdefID)
{
	for(size_t i = 0; i < cacheData.size(); i++)
	{
		if(cacheData[i].creatureDefID == cdefID)
		{
			cacheData.erase(cacheData.begin() + i);
			return;
		}
	}
}

void CharacterCacheManager :: SaveToStream(FILE *output)
{
	fprintf(output, "[CHARACTERCACHE]\r\n");
	for(size_t i = 0; i < cacheData.size(); i++)
	{
		fprintf(output, "[CACHEENTRY]\r\n");
		fprintf(output, "creatureDefID=%d\r\n", cacheData[i].creatureDefID);
		fprintf(output, "level=%d\r\n", cacheData[i].level);
		fprintf(output, "profession=%d\r\n", cacheData[i].profession);
		fprintf(output, "display_name=%s\r\n", cacheData[i].display_name.c_str());
		fprintf(output, "appearance=%s\r\n", cacheData[i].appearance.c_str());
		fprintf(output, "eq_appearance=%s\r\n", cacheData[i].eq_appearance.c_str());
		fprintf(output, "[/CACHEENTRY]\r\n");
	}
	fprintf(output, "[/CHARACTERCACHE]\r\n");
}

void CharacterCacheManager :: AddEntry(CharacterCacheEntry &data)
{
	cacheData.push_back(data);
}





UsedNameDatabase :: UsedNameDatabase()
{
}

UsedNameDatabase :: ~UsedNameDatabase()
{
}

UsedNameDatabase::CONTAINER_REF UsedNameDatabase :: GetData(void)
{
	return mData;
}

void UsedNameDatabase :: Add(int CDefID, const char *name, bool loadStage)
{
	mData[CDefID] = name;
	mNameLookup[name] = CDefID;
	if(loadStage == false)
		mChanges.AddChange();
}

void UsedNameDatabase :: Remove(int CDefID)
{
	ITERATOR it = mData.find(CDefID);
	if(it == mData.end())
		return;

	//Erase from the reverse data map, then the main data map.
	NAME_ITERATOR nit = mNameLookup.find(it->second);
	if(nit != mNameLookup.end())
		mNameLookup.erase(nit);

	mData.erase(it);
	mChanges.AddChange();
}

size_t UsedNameDatabase :: GetDataCount(void)
{
	return mData.size();
}

bool UsedNameDatabase :: HasID(int CDefID)
{
	ITERATOR it = mData.find(CDefID);
	if(it == mData.end())
		return false;
	return true;
}

const char* UsedNameDatabase :: GetNameByID(int CDefID)
{
	ITERATOR it = mData.find(CDefID);
	if(it == mData.end())
		return NULL;
	return it->second.c_str();
}

int UsedNameDatabase :: GetIDByName(const char *name)
{
	NAME_ITERATOR it = mNameLookup.find(name);
	if(it == mNameLookup.end())
		return -1;
	return it->second;
}

bool UsedNameDatabase :: HasName(const char *name)
{
	NAME_ITERATOR it = mNameLookup.find(name);
	if(it == mNameLookup.end())
		return false;
	return true;
}

bool UsedNameDatabase :: HasChanged(void)
{
	return (mChanges.PendingChanges != 0);
}


