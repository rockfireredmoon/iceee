#include <stdio.h>
#include <stdlib.h>
#include "FileReader.h"

#include "Account.h"
#include "Character.h"

#include "Config.h"
#include "Info.h"
#include "DirectoryAccess.h"

#include "Character.h"
#include "Item.h"
#include "Globals.h"
#include "ZoneDef.h"
#include "Util.h"
#include "StringUtil.h"
#include "Cluster.h"
#include "ConfigString.h"
#include "Inventory.h"
#include "FriendStatus.h"
#include "util/Log.h"
#include "md5.hh"

//char *GetValueOfKey(MULTISTRING &extract, const char *key);  //External function

//extern char GAuxBuf[];

AccountManager g_AccountManager;
UsedNameDatabase g_UsedNameDatabase;

PermissionInfo PermissionDef[] = {
		{ Perm_Account, 0, Permission_TweakOther, "tweakother" },
		{ Perm_Account, 0, Permission_TweakSelf, "tweakself" },
		{ Perm_Account, 0, Permission_TweakNPC, "tweaknpc" },
		{ Perm_Account, 0, Permission_TweakClient, "tweakclient" },
		{ Perm_Account, 0, Permission_SysChat, "syschat" },
		{ Perm_Account, 0, Permission_GMChat, "gmchat" },
		{ Perm_Account, 0, Permission_RegionChat, "regionchat" },
		{ Perm_Account, 0, Permission_ForumPost, "forumpost" },
		{ Perm_Account, 0, Permission_ForumAdmin, "forumadmin" },
		{ Perm_Account, 0, Permission_ItemGive, "itemgive" },
		{ Perm_Account, 0, Permission_Debug, "debug" },
		{ Perm_Account, 0, Permission_Sage,	"sage" },
		{ Perm_Account, 0, Permission_FastLoad, "fastload" },
		{ Perm_Account, 0, Permission_Admin, "admin" },
		{ Perm_Account, 0, Permission_PasswordReset, "passwordreset" },
		{ Perm_Account, 0, Permission_Invisible, "invisible" },
		{ Perm_Account, 0, Permission_SelfDiag, "selfdiag" },
		{ Perm_Account, 0, Permission_Troll, "troll" },
		{ Perm_Account, 0, Permission_TrollChat, "trollchat" },
		{ Perm_Account, 0, Permission_Builder, "builder" },
		{ Perm_Account, 0, Permission_Veteran, "veteran" },
		{Perm_Account, 0, Permission_Developer, "developer" },
		{ Perm_Account, 0, Permission_FullSet, "fullset" } };
const int MaxPermissionDef = sizeof(PermissionDef) / sizeof(PermissionInfo);

//Byte sequence generated by http://www.random.org/
//WARNING: Changing this will invalidate the keys of any existing accounts.
const char RandomSalt[] =
		"W7UDynoSUED5zbdA5ldiSlxV9DX0Fssl8VdhRUZWkG6D6XRGETXKRVdJMI2LAGvZyawgHkD26OIKDxz4"
				"xrWdol3RQp8JJ79lmCRQHfMBVa0jXyUaZSxq23lRNBjzMBKymxXmfZ9ugfuvIbV9NpF4b7K5GgACcWy7"
				"Xwz2P4wLYknUtIFLLZcQqFhlrcXRpsbtmc4JzKJqKPrsLlKby0PF3EGhSOLWfXO0bRrvpvXoxtuDnh2Z"
				"F6GUqW4X9JeFvMbLV8mcMm1i37SNPMwILzy1JqbYTeVtJLDozCVftVo4dBQJcgb9CMLGeCxO5DT2Xw5X"
				"gcyJgYXFFwRatjdPyLs4boM3aCTyWsNyNFfHArHati2mFGBS5CXqfazIhau6hyMlkxmGR3WUxioCpzq4"
				"H7q6usn8oSETobwEqsAqdVeMk06621glbeV9yofr7SapSTnp2xXSyklDcr5hOiEoFdCLkePQQoAEAtEx"
				"jKLu0aTpKMRmysq5kTiS";

//
// AccessToken
//
AccessToken::AccessToken() {
	expire = 0;
	uses = 0;
	tokenType = ACCESS_TOKEN;
	accountID = 0;
}
AccessToken::~AccessToken() {
}

//
// CharacterCacheEntry
//
CharacterCacheEntry::CharacterCacheEntry() {
	creatureDefID = 0;
	level = 0;
	profession = 0;
}
CharacterCacheEntry::~CharacterCacheEntry() {
}

void CharacterCacheEntry::Clear() {
	creatureDefID = 0;
	level = 0;
	profession = 0;
	display_name.clear();
	appearance.clear();
	eq_appearance.clear();
}

bool CharacterCacheEntry::WriteEntity(AbstractEntityWriter *writer) {
	writer->Value("CreatureDefID", creatureDefID);
	writer->Value("Level", level);
	writer->Value("Profession", profession);
	writer->Value("Display_Name", display_name);
	writer->Value("Appearance", appearance);
	writer->Value("EQ_Appearance", eq_appearance);
	return true;
}

bool CharacterCacheEntry::EntityKeys(AbstractEntityReader *reader) {
	return true;
}

bool CharacterCacheEntry::ReadEntity(AbstractEntityReader *reader) {
	creatureDefID = reader->ValueInt("CreatureDefID");
	level = reader->ValueInt("Level");
	profession = reader->ValueInt("Profession");
	display_name = reader->Value("Display_Name");
	appearance = reader->Value("Appearance");
	eq_appearance = reader->Value("EQ_Appearance");
	return true;
}

//
// AccountQuickData
//

bool AccountQuickData::WriteEntity(AbstractEntityWriter *writer) {
	writer->Key(KEYPREFIX_ACCOUNT_QUICK_DATA, mLoginName);
	writer->Value("ID", mID);
	writer->Value("LoginAuth", mLoginAuth);
	writer->Value("RegKey", mRegKey);
	writer->Value("GroveName", mGroveName);
	return true;
}

bool AccountQuickData::EntityKeys(AbstractEntityReader *reader) {
	reader->Key(KEYPREFIX_ACCOUNT_QUICK_DATA, mLoginName, true);
	return true;
}

bool AccountQuickData::ReadEntity(AbstractEntityReader *reader) {
	mID = reader->ValueInt("ID");
	mLoginAuth = reader->Value("LoginAuth");
	mRegKey = reader->Value("RegKey");
	mGroveName = reader->Value("GroveName");
	return true;
}

//
// AccountData
//

AccountData::AccountData() {
	ClearAll();
}

AccountData::~AccountData() {
	ClearAll();
}

void AccountData::SetRoles(std::vector<std::string> &roles) {

	bool admin = std::find(roles.begin(), roles.end(), "administrator")
			!= roles.end();
	bool sage = std::find(roles.begin(), roles.end(), "sage") != roles.end();
	bool builder = std::find(roles.begin(), roles.end(), "builder")
			!= roles.end();
	bool developer = std::find(roles.begin(), roles.end(), "developer")
			!= roles.end();
	bool tweaker = std::find(roles.begin(), roles.end(), "tweaker")
			!= roles.end();
	bool veteran = std::find(roles.begin(), roles.end(), "veteran")
			!= roles.end();

	// Sages and admins get sage
	bool needSage = sage || admin || builder || developer;
	if (needSage != HasPermission(Perm_Account, Permission_Sage)) {
		SetPermission(Perm_Account, "sage", needSage);
		PendingMinorUpdates++;
	}

	// Admin and developer gets admin

	bool needAdmin = admin || developer;
	if (needAdmin != HasPermission(Perm_Account, Permission_Admin)) {
		SetPermission(Perm_Account, "admin", needAdmin);
		PendingMinorUpdates++;
	}

	// Sages and admins get debug
	bool needDebug = admin || builder || developer;
	if (needDebug != HasPermission(Perm_Account, Permission_Debug)) {
		SetPermission(Perm_Account, "debug", needDebug);
		PendingMinorUpdates++;
	}

	// Builders
	bool needBuilder = builder || admin;
	if (needBuilder != HasPermission(Perm_Account, Permission_Builder)) {
		SetPermission(Perm_Account, "builder", needBuilder);
		PendingMinorUpdates++;
	}

	// Veteran
	if (veteran != HasPermission(Perm_Account, Permission_Veteran)) {
		SetPermission(Perm_Account, "veteran", veteran);
		PendingMinorUpdates++;
	}

	// Item give
	bool needItemGive = sage || admin;
	if (needItemGive != HasPermission(Perm_Account, Permission_ItemGive)) {
		SetPermission(Perm_Account, "itemgive", needItemGive);
		PendingMinorUpdates++;
	}

	// Tweakers
	bool needClientTweak = tweaker || admin || sage || builder || developer;
	if (needClientTweak
			!= HasPermission(Perm_Account, Permission_TweakClient)) {
		SetPermission(Perm_Account, "tweakclient", needClientTweak);
		PendingMinorUpdates++;
	}
	bool needSelfTweak = admin || builder || developer;
	if (needSelfTweak != HasPermission(Perm_Account, Permission_TweakSelf)) {
		SetPermission(Perm_Account, "tweakself", needSelfTweak);
		PendingMinorUpdates++;
	}
	bool needNPCTweak = admin || builder || developer;
	if (needNPCTweak != HasPermission(Perm_Account, Permission_TweakNPC)) {
		SetPermission(Perm_Account, "tweaknpc", needNPCTweak);
		PendingMinorUpdates++;
	}
	bool needOtherTweak = admin;
	if (needOtherTweak != HasPermission(Perm_Account, Permission_TweakOther)) {
		SetPermission(Perm_Account, "tweakother", needOtherTweak);
		PendingMinorUpdates++;
	}
	bool needSysChat = admin;
	if (needSysChat != HasPermission(Perm_Account, Permission_SysChat)) {
		SetPermission(Perm_Account, "syschat", needSysChat);
		PendingMinorUpdates++;
	}
	bool needGMChat = admin;
	if (needGMChat != HasPermission(Perm_Account, Permission_GMChat)) {
		SetPermission(Perm_Account, "gmchat", needGMChat);
		PendingMinorUpdates++;
	}
}

bool AccountData::EntityKeys(AbstractEntityReader *reader) {
	reader->Key(KEYPREFIX_ACCOUNT_DATA, StringUtil::Format("%d", ID));
	reader->Index("CHARACTERCACHE/CACHEENTRY");
	return true;
}

bool AccountData::ReadEntity(AbstractEntityReader *reader) {
	if (!reader->Exists())
		return false;

	Name = reader->Value("Name");
	AuthData = reader->Value("Auth");
	RegKey = reader->Value("RegKey");
	RecoveryKeys = reader->Value("RecoveryKeys");
	SuspendTimeSec = reader->ValueULong("SuspendTime");
	SuspendDurationSec = reader->ValueULong("SuspendDuration");
	MaxCharacters = reader->ValueULong("MaxCharacters");
	if (MaxCharacters < AccountData::DEFAULT_CHARACTER_SLOTS) {
		MaxCharacters = AccountData::DEFAULT_CHARACTER_SLOTS;
	}
	LastLogOn = reader->Value("LastLogOn");
	ConsecutiveDaysLoggedIn = reader->ValueULong("ConsecutiveDaysLoggedIn");
	Credits = reader->ValueULong("Credits");
	LastLogOnTimeSec = reader->ValueULong("LastLogOnTime");
	CreatedTimeSec = reader->ValueULong("CreatedTime");
	DeliveryBoxSlots = reader->ValueInt("DeliveryBoxSlots");
	VeteranLevel = reader->ValueInt("VeteranLevel");
	VeteranImported = reader->ValueBool("VeteranImported");
	STRINGLIST characters = reader->ListValue("Characters", ",");
	int s = 0;
	for (auto a = characters.begin(); a != characters.end(); ++a) {
		if (s < AccountData::MAX_CHARACTER_SLOTS)
			CharacterSet[s] = atoi((*a).c_str());
		s++;
	}
	if (s > MaxCharacters)
		MaxCharacters = s;
	STRINGLIST perms = reader->ListValue("Permissions", ",");
	for (auto a = perms.begin(); a != perms.end(); ++a) {
		if (SetPermission(Perm_Account, StringUtil::LowerCase(*a).c_str(), true)
				== false)
			g_Logs.data->warn(
					"Unknown permission identifier [%v] in Account %v.", ID);
	}
	STRINGLIST achievements = reader->ListValue("Achievements");
	for (auto a = achievements.begin(); a != achievements.end(); ++a)
		AddAchievement(*a);
	GroveName = reader->Value("GroveName");
	STRINGLIST aq = reader->ListValue("AccountQuest", ",");
	for (auto a = aq.begin(); a != aq.end(); ++a) {
		int qid = atoi((*a).c_str());
		if (HasAccountCompletedQuest(qid))
			g_Logs.data->warn(
					"Account %v has multiple account quests with same ID %v, ignoring",
					ID, qid);
		else
			AccountQuests.push_back(qid);
	}
	SiteSession.xCSRF = reader->Value("xCSRF");
	SiteSession.sessionID = reader->Value("SessionID");
	SiteSession.sessionName = reader->Value("SessionName");
	STRINGLIST build = reader->ListValue("Build");
	for (auto a = build.begin(); a != build.end(); ++a) {
		STRINGLIST l;
		Util::Split(*a, ",", l);
		if (l.size() > 4) {
			BuildPermissionArea bpa;
			bpa.ZoneID = atoi(l[0].c_str());
			bpa.x1 = atoi(l[1].c_str());
			bpa.y1 = atoi(l[2].c_str());
			bpa.x2 = atoi(l[3].c_str());
			bpa.y2 = atoi(l[4].c_str());

			if (HasBuildZone(bpa) == false)
				BuildPermissionList.push_back(bpa);
		} else {
			g_Logs.data->warn("Invalid Build permissions spec '%v' for %v", *a,
					ID);
		}
	}
	STRINGLIST prefs = reader->ListValue("Pref");
	for (auto a = prefs.begin(); a != prefs.end(); ++a) {
		size_t found = (*a).find_last_of(",");
		if (found == string::npos)
			preferenceList.SetPref((*a).c_str(), "");
		else {
			string k = (*a).substr(0, found);
			string v = (*a).substr(found + 1).c_str();
			preferenceList.SetPref(k.c_str(), v.c_str());
		}
	}
	PlayerStats.ReadEntity(reader);

	for (int a = 0; a < MAXCONTAINER; a++) {
		if (IsContainerIDValid(a)) {
			std::string cnt = GetContainerNameFromID(a);
			STRINGLIST inv = reader->ListValue(cnt);
			for (auto a = inv.begin(); a != inv.end(); ++a) {
				ReadInventory(cnt, *a, inventory, StringUtil::Format("%d", ID),
						Name, "Account");
			}
		}
	}

	reader->PushSection("CHARACTERCACHE");
	characterCache.ReadEntity(reader);
	reader->PopSection();

	return true;
}

bool AccountData::WriteEntity(AbstractEntityWriter *writer) {
	writer->Key(KEYPREFIX_ACCOUNT_DATA, StringUtil::Format("%d", ID));
	writer->Value("Name", Name);
	writer->Value("Auth", AuthData);
	writer->Value("RegKey", RegKey);
	if (MaxCharacters != DEFAULT_CHARACTER_SLOTS)
		writer->Value("MaxCharacters", MaxCharacters);
	writer->Value("RecoveryKeys", RecoveryKeys);
	if (SuspendTimeSec >= 0) {
		writer->Value("SuspendTime", SuspendTimeSec);
		writer->Value("SuspendDuration", SuspendDurationSec);
	}
	writer->Value("LastLogOn", LastLogOn);
	writer->Value("LastLogOnTime", LastLogOnTimeSec);
	writer->Value("CreatedTime", CreatedTimeSec);
	writer->Value("ConsecutiveDaysLoggedIn", ConsecutiveDaysLoggedIn);
	writer->Value("Credits", Credits);
	writer->Value("DeliveryBoxSlots", DeliveryBoxSlots);
	writer->Value("VeteranLevel", VeteranLevel);
	writer->Value("VeteranImported", VeteranImported);

	STRINGLIST l;
	for (int a = 0; a < MaxCharacters; a++) {
		if (CharacterSet[a] == 0)
			continue;
		l.push_back(StringUtil::Format("%d", CharacterSet[a]));
	}
	writer->ListValue("Characters", l);

	l = STRINGLIST();
	for (int a = 0; a < MaxPermissionDef; a++)
		if ((PermissionSet[PermissionDef[a].index] & PermissionDef[a].flag)
				== PermissionDef[a].flag)
			l.push_back(PermissionDef[a].name);
	writer->ListValue("Permissions", l);

	l = STRINGLIST();
	for (std::map<std::string, Achievements::Achievement>::iterator it =
			Achievements.begin(); it != Achievements.end(); ++it)
		for (std::vector<Achievements::AchievementObjectiveDef*>::iterator it2 =
				(*it).second.mCompletedObjectives.begin();
				it2 != (*it).second.mCompletedObjectives.end(); ++it2)
			l.push_back(
					StringUtil::Format("%s/%s", (*it).first.c_str(),
							(*it2)->mName.c_str()));
	writer->ListValue("Achievements", l);

	writer->Value("GroveName", GroveName);

	PlayerStats.WriteEntity(writer);

	//	Util::WriteString(output, "xCSRF", SiteSession.xCSRF);
	//	Util::WriteString(output, "SessionName", SiteSession.sessionName);
	//	Util::WriteString(output, "SessionID", SiteSession.sessionID);

	l = STRINGLIST();
	for (size_t i = 0; i < BuildPermissionList.size(); i++) {
		BuildPermissionArea &bpa = BuildPermissionList[i];
		l.push_back(
				StringUtil::Format("%d,%d,%d,%d,%d", bpa.ZoneID, bpa.x1, bpa.y1,
						bpa.x2, bpa.y2));
	}
	writer->ListValue("Build", l);

	l = STRINGLIST();
	for (auto it = AccountQuests.begin(); it != AccountQuests.end(); ++it)
		l.push_back(StringUtil::Format("%d", *it));
	writer->ListValue("AccountQuest", l);

	l = STRINGLIST();
	for (auto a = preferenceList.PrefList.begin();
			a != preferenceList.PrefList.end(); ++a) {
		l.push_back(
				StringUtil::Format("%s,%s", (*a).name.c_str(),
						(*a).value.c_str()));
	}
	writer->ListValue("Pref", l);

	int a, b;
	for (a = 0; a < MAXCONTAINER; a++) {
		if (IsContainerIDValid(a)) {
			l = STRINGLIST();
			for (b = 0; b < (int) inventory.containerList[a].size(); b++) {
				InventorySlot *slot = &inventory.containerList[a][b];

				bool extend = false;
				if (slot->count > 0 || slot->customLook != 0
						|| slot->bindStatus != 0
						|| slot->secondsRemaining != -1)
					extend = true;

				if (extend == true)
					l.push_back(
							StringUtil::Format("%lu,%d,%d,%d,%d,%ld",
									slot->CCSID & CONTAINER_SLOT, slot->IID,
									slot->count, slot->customLook,
									slot->bindStatus, slot->AdjustTimes()));
				else
					l.push_back(
							StringUtil::Format("%lu,%d",
									slot->CCSID & CONTAINER_SLOT, slot->IID));
			}
			if (l.size() > 0)
				writer->ListValue(GetContainerNameFromID(a), l);
		}
	}

	//TODO:VAULT fprintf(output, "CurrentVaultSize=%d\r\n", CurrentVaultSize);
	//	for(size_t i = 0; i < vaultInventory.size(); i++)
	//		vaultInventory[i].SaveToAccountStream("bank", output);
	//	for(size_t i = 0; i < deliveryInventory.size(); i++)
	//		deliveryInventory[i].SaveToAccountStream("delivery", output);

	writer->PushSection("CHARACTERCACHE");
	characterCache.WriteEntity(writer);
	writer->PopSection();
	PendingMinorUpdates = 0;
	return true;
}

void AccountData::ClearAll(void) {
	ID = 0;
	Name = "";
	//memset(AuthPass, 0, sizeof(AuthPass));
	AuthData = "";
	RegKey = "";
	RecoveryKeys.clear();
	memset(CharacterSet, 0, sizeof(CharacterSet));
	//memset(ResCharacterSet, 0, sizeof(ResCharacterSet));
	memset(PermissionSet, 0, sizeof(PermissionSet));
	GroveName.clear();
	AccountQuests.clear();
	BuildPermissionList.clear();
	preferenceList.PrefList.clear();
	PendingMinorUpdates = 0;

	SuspendDurationSec = 0;
	SuspendTimeSec = 0;
	MaxCharacters = DEFAULT_CHARACTER_SLOTS;

	LastLogOnTimeSec = 0;
	CreatedTimeSec = 0;
	ConsecutiveDaysLoggedIn = 0;

	Credits = 0;
	DeliveryBoxSlots = 0;
	VeteranLevel = 0;
	VeteranImported = false;
	inventory.ClearAll();
//	deliveryInventory.clear();
	LastLogOn = "";

	ExpireTime = 0;

	PlayerStats.Clear();

	SiteSession.Clear();

	//CurrentVaultSize = DEFAULT_VAULT_SIZE;
}

void AccountData::FillAuthorizationHash(const char *hash) {
	AuthData = hash;
}
void AccountData::FillRegistrationKey(const char *key) {
	RegKey = key;
}

bool AccountData::MatchAuthData(const char *str) {
	if (strcmp(AuthData.c_str(), str) == 0)
		return true;

	return false;
}

void AccountData::ResolveCharacters(const char *debugName) {
	/* TODO: Revamp
	 int ci;
	 int NChar = 0;
	 for(ci = 0; ci < MaxCharacters; ci++)
	 {
	 int index = CharacterSet[ci];
	 if(index > 0)
	 {
	 int ret = GetCharacterIndex(index);
	 if(ret >= 0)
	 {
	 ResCharacterSet[NChar] = ret;
	 NChar++;
	 }
	 else
	 g_Log.AddMessageFormat("Warning: cannot find character index %d for account %s.", index, debugName);
	 }
	 }
	 NumCharacters = NChar;
	 */
}

int AccountData::GetCharacterCount(void) {
	int count = 0;
	for (int a = 0; a < MAX_CHARACTER_SLOTS; a++)
		if (CharacterSet[a] != 0)
			count++;
	return count;
}

bool AccountData::SetPermission(short filterType, const char *name,
		bool value) {
	int a;
	for (a = 0; a < MaxPermissionDef; a++) {
		if (PermissionDef[a].type == filterType) {
			if (strcmp(PermissionDef[a].name, name) == 0) {
				if (value == true)
					PermissionSet[PermissionDef[a].index] |=
							PermissionDef[a].flag;
				else
					PermissionSet[PermissionDef[a].index] &=
							(~(PermissionDef[a].flag));
				return true;
			}
		}
	}
	return false;
}

bool AccountData::HasPermission(short permissionSet,
		unsigned int permissionFlag) {
	if (PermissionSet[permissionSet] & permissionFlag)
		return true;

	return false;
}

int AccountData::GetFreeCharacterSlot(void) {
	for (int a = 0; a < MaxCharacters; a++)
		if (CharacterSet[a] == 0)
			return a;
	return -1;
}

bool AccountData::CheckBuildPermission(int zoneID, int pagex, int pagey) {
	if (HasPermission(Perm_Account, Permission_Builder)) {
		return true;
	}
	for (size_t i = 0; i < BuildPermissionList.size(); i++) {
		BuildPermissionArea &bpa = BuildPermissionList[i];
		if (bpa.ZoneID == zoneID) {
			if (pagex >= bpa.x1 && pagex <= bpa.x2)
				if (pagey >= bpa.y1 && pagey <= bpa.y2)
					return true;
		}
	}
	return false;
}

bool AccountData::CheckBuildPermissionAdv(int zoneID, int PageSize, float posx,
		float posz) {
	if (HasPermission(Perm_Account, Permission_Builder)) {
		return true;
	}
	//Need increased resolution since negative positions may round to zero.
	int px = (int) posx;
	int pz = (int) posz;
	for (size_t i = 0; i < BuildPermissionList.size(); i++) {
		BuildPermissionArea &bpa = BuildPermissionList[i];
		if (bpa.ZoneID == zoneID) {
			// Position 0,0 effectively ranges from 0,0 to PageSize-1,PageSize-1
			// So we need to expand the x2,y2 boundary to include for an extra cell.
			int x1 = bpa.x1 * PageSize;
			int y1 = bpa.y1 * PageSize;
			int x2 = ((bpa.x2 + 1) * PageSize) - 1;
			int y2 = ((bpa.y2 + 1) * PageSize) - 1;
			if (px >= x1 && px <= x2)
				if (pz >= y1 && pz <= y2)
					return true;
		}
	}
	return false;
}

bool AccountData::HasCharacterID(int CDefID) {
	for (int a = 0; a < MAX_CHARACTER_SLOTS; a++)
		if (CharacterSet[a] == CDefID)
			return true;
	return false;
}

int AccountData::GetTotalAchievementObjectives() {
	int c = 0;
	for (std::map<std::string, Achievements::Achievement>::iterator it =
			Achievements.begin(); it != Achievements.end(); ++it) {
		c += it->second.mCompletedObjectives.size();
	}
	return c;
}

int AccountData::GetTotalCompletedAchievements() {
	int c = 0;
	for (std::map<std::string, Achievements::Achievement>::iterator it =
			Achievements.begin(); it != Achievements.end(); ++it) {
		if ((*it).second.IsComplete())
			c++;
	}
	return c;
}

void AccountData::AddAchievement(std::string achievement) {
	std::vector<std::string> l;
	Util::Split(achievement, "/", l);
	if (l.size() > 1) {
		Achievements::AchievementDef *def = g_AchievementsManager.GetItem(l[0]);
		if (def == NULL) {
			g_Logs.data->warn("No such achievement, %v for %v (%v)",
					l[0].c_str(), Name, ID);
			return;
		}
		if (Achievements.find(l[0]) == Achievements.end()) {
			Achievements[l[0]] = Achievements::Achievement(def);
		}
		Achievements[l[0]].CompleteObjective(l[1]);
	} else
		g_Logs.data->warn("Incorrect achievement spec, %v for %v (%v)",
				achievement.c_str(), Name, ID);
}

bool AccountData::HasAccountCompletedQuest(int QuestID) {
	return std::find(AccountQuests.begin(), AccountQuests.end(), QuestID)
			!= AccountQuests.end();
}

bool AccountData::HasBuildZone(BuildPermissionArea &bpa) {
	for (size_t i = 0; i < BuildPermissionList.size(); i++) {
		BuildPermissionArea &has = BuildPermissionList[i];
		if (has.ZoneID != bpa.ZoneID)
			continue;
		if (has.x1 != bpa.x1)
			continue;
		if (has.x2 != bpa.x2)
			continue;
		if (has.y1 != bpa.y1)
			continue;
		if (has.y2 != bpa.y2)
			continue;
		return true;
	}
	return false;
}

void AccountData::SetBan(int minutes) {
	SuspendDurationSec = minutes * 60;
	SuspendTimeSec = g_PlatformTime.getAbsoluteSeconds();
	PendingMinorUpdates++;
}

bool AccountData::ExpandDeliveryBoxes() {
	if (DeliveryBoxSlots < MAX_DELIVERY_BOX_SLOTS) {
		DeliveryBoxSlots++;
		PendingMinorUpdates++;
		return true;
	}
	return false;
}

bool AccountData::ExpandCharacterSlots() {
	if (MaxCharacters < MAX_CHARACTER_SLOTS) {
		MaxCharacters++;
		PendingMinorUpdates++;
		return true;
	}
	return false;
}

void AccountData::ClearBan(void) {
	SuspendDurationSec = 0;
	SuspendTimeSec = 0;
	PendingMinorUpdates++;
}

void AccountData::AdjustSessionLoginCount(short count) {
	if (count == 1) {
		// Login
		g_ClusterManager.Login(ID);
	} else if (count == -1) {
		// Logout
		g_ClusterManager.Logout(ID);

	}
	if (g_ClusterManager.CountAccountSessions(ID) > 0) {
		ExpireTime = PlatformTime::MAX_TIME;
	} else {
		ExpireTime = g_ServerTime + EXPIRE_TIME;
	}
}

/* Determine if the account is ready for unloading. Normally honors login time unless forced
 to unload, such as during shutdown.*/
bool AccountData::QualifyGarbage(bool force) {
	if (g_ClusterManager.CountAccountSessions(ID, true, false) > 0)
		return false;

	if (PendingMinorUpdates > 0)
		return false;

	if (g_ServerTime >= ExpireTime || force == true)
		return true;

	return false;
}

//Generate a password hash that the EE client would send, provided the plain text for username and password.
//The supplied password to this function must be the raw unhashed password.
//  MD5(username + ":" + MD5(password) + ":" + salt)
void AccountData::GenerateClientPasswordHash(const char *username,
		const char *password, std::string &outputString) {
	MD5 passwordHash;
	passwordHash.update((unsigned char*) password, strlen(password));
	passwordHash.finalize();

	std::string buf;

	buf = username;
	buf.append(":");
	buf.append(passwordHash.hex_digest());
	buf.append(":");
	buf.append(g_AuthKey);

	MD5 finalHash;
	finalHash.update((unsigned char*) buf.c_str(), buf.size());
	finalHash.finalize();

	outputString = finalHash.hex_digest();
}

//Generate a new hash from a string, in the form of MD5(inputstring + salt)
void AccountData::GenerateSaltedHash(const char *inputString,
		std::string &outputString) {
	const char *salt = (char*) RandomSalt; //Need to typecast for the append to work.

	std::string s;
	s.append(inputString);
	s.append(salt, sizeof(RandomSalt));

	MD5 hash;
	hash.update((unsigned char*) s.c_str(), s.size());
	hash.finalize();

	outputString = hash.hex_digest();
}

void AccountData::GenerateAndApplyRegistrationKeyRecovery(void) {
	if (IsRegistrationKeyEmpty() == true)
		return;

	ConfigString str(RecoveryKeys);

	std::string rkhash;
	GenerateSaltedHash(RegKey.c_str(), rkhash);
	str.SetKeyValue("regkey", rkhash.c_str());

	std::string result;
	str.GenerateString(result);

	RecoveryKeys = result;
	PendingMinorUpdates++;
}

bool AccountData::MatchRecoveryKey(const char *type, const char *hash) {
	ConfigString keys(RecoveryKeys);
	if (keys.HasKey(type) == false)
		return false;

	std::string value;
	keys.GetValueString(type, value);

	if (value.compare(hash) == 0)
		return true;

	return false;
}

void AccountData::SetNewPassword(const char *username,
		const char *plainTextPassword) {
	std::string pwHash;
	GenerateClientPasswordHash(username, plainTextPassword, pwHash);

	//Extra step for server-side passwords.
	AccountData::GenerateSaltedHash(pwHash.c_str(), pwHash);
	FillAuthorizationHash(pwHash.c_str());
	PendingMinorUpdates++;
}

void AccountData::SetNewRegistrationKey(const char *regkey) {
	FillRegistrationKey(regkey);
	GenerateAndApplyRegistrationKeyRecovery();
}

bool AccountData::MatchRegistrationKey(const char *regkey) {
	if (regkey == NULL)
		return false;

	//If the key wiped, automatically check the recovery key and restore the key if necessary.
	CheckRecoveryRegistrationKey(regkey);

	if (IsRegistrationKeyEmpty() == true)
		return false;

	if (strlen(regkey) != strlen(RegKey.c_str()))
		return false;
	if (strcmp(RegKey.c_str(), regkey) != 0)
		return false;

	return true;
}

bool AccountData::IsRegistrationKeyEmpty(void) {
	//Consider single digit keys to be wiped and invalid.
	if (strlen(RegKey.c_str()) <= 1)
		return true;

	return false;
}

void AccountData::CheckRecoveryRegistrationKey(const char *regkey) {
	if (IsRegistrationKeyEmpty() == false)
		return;

	//Only try to restore keys if the registration key field is empty.

	ConfigString str(RecoveryKeys);
	if (str.HasKey("regkey") == true) {
		//Hash the provided key 
		std::string convertedKey;
		GenerateSaltedHash(regkey, convertedKey);

		//Retrieve the recovery key
		std::string recoveryKey;
		str.GetValueString("regkey", recoveryKey);

		if (convertedKey.compare(recoveryKey) == 0) {
			//It matches, restore the key.
			FillRegistrationKey(regkey);
			PendingMinorUpdates++;

			g_AccountManager.AppendQuickData(this);

			g_Logs.data->warn(
					"Account [%v] missing registration key was restored from recovery key.",
					Name);
		}
	}
}

void AccountData::ReadFromJSON(Json::Value &value) {
	Name = value.get("name", "").asString();
	ID = value.get("id", 0).asInt();

	characterCache.cacheData.clear();

	Json::Value characters = value["characters"];
	for (Json::Value::iterator it = characters.begin(); it != characters.end();
			++it) {
		CharacterCacheEntry cce;
		cce.display_name = characters.get("name", "").asString();
		cce.level = characters.get("level", 0).asInt();
		cce.profession = characters.get("profession", 0).asInt();
		cce.appearance = characters.get("appearance", 0).asString();
		cce.eq_appearance = characters.get("eqAppearance", 0).asString();
		characterCache.cacheData.push_back(cce);
	}
	SuspendDurationSec = value["suspend"].asLargestUInt();
	SuspendTimeSec = value["suspended"].asLargestUInt();
	LastLogOn = value["logon"].asString();
	LastLogOnTimeSec = value["logonTime"].asLargestUInt();
	CreatedTimeSec = value["createdTime"].asLargestUInt();
	ConsecutiveDaysLoggedIn = value["days"].asInt();
	Credits = value["credits"].asInt();
	DeliveryBoxSlots = value["deliveryBoxes"].asInt();
	VeteranLevel = value["veteranLevel"].asInt();
	VeteranImported = value["veteranImported"].asBool();
	MaxCharacters = value["max"].asInt();
	GroveName = value["grove"].asString();
	PlayerStats.Clear();
	if (value.isMember("playerStats")) {
		PlayerStats.ReadFromJSON(value["playerStats"]);
	}
}

void AccountData::WriteToJSON(Json::Value &value) {
	value["name"] = Name;
	value["id"] = ID;

	Json::Value characters;
	for (std::vector<CharacterCacheEntry>::iterator it =
			characterCache.cacheData.begin();
			it != characterCache.cacheData.end(); ++it) {
		CharacterCacheEntry cce = *it;
		Json::Value character;
		character["name"] = cce.display_name;
		character["level"] = cce.level;
		character["profession"] = cce.profession;
		character["appearance"] = cce.appearance;
		character["eqAppearance"] = cce.eq_appearance;
		characters[cce.display_name] = character;
	}
	for (int i = 0; i < MAX_CHARACTER_SLOTS; i++) {
		if (CharacterSet[i] > 0)
			characters.append(CharacterSet[i]);
	}
	value["characters"] = characters;
	value["suspend"] = Json::UInt64(SuspendDurationSec);
	value["suspended"] = Json::UInt64(SuspendTimeSec);
	value["logon"] = LastLogOn;
	value["logonTime"] = Json::UInt64(LastLogOnTimeSec);
	value["createdTime"] = Json::UInt64(CreatedTimeSec);
	value["days"] = ConsecutiveDaysLoggedIn;
	value["credits"] = Credits;
	value["deliveryBoxes"] = DeliveryBoxSlots;
	value["veteranLevel"] = VeteranLevel;
	value["veteranImported"] = VeteranImported;
	value["grove"] = GroveName;
	value["max"] = MaxCharacters;

	Json::Value ps;
	PlayerStats.WriteToJSON(ps);
	value["playerStats"] = ps;
}

AccountManager::AccountManager() {
	cs.Init();
	cs.SetDebugName("CS_ACCOUNT");
}

AccountManager::~AccountManager() {
	UnloadAllData();
}

AccountQuickData AccountManager::GetAccountQuickDataByUsername(
		const std::string &username) {
	AccountQuickData qd;
	qd.mLoginName = username;
	g_ClusterManager.ReadEntity(&qd);
	return qd;
}

AccountData * AccountManager::GetValidLogin(const char *loginName,
		const char *loginAuth) {
	//Takes the given login name and account strings, searching through the loaded
	//account list to find an entry that matches the given credentials.

	AccountQuickData aqd = GetAccountQuickDataByUsername(loginName);
	if (aqd.mID != 0 && aqd.mLoginAuth.compare(loginAuth) == 0)
		return FetchIndividualAccount(aqd.mID);
	return NULL;
}

void AccountManager::ResolveCharacters(void) {
	ACCOUNT_ITERATOR it;
	for (it = AccList.begin(); it != AccList.end(); ++it)
		it->ResolveCharacters(it->Name.c_str());
}

int AccountManager::CreateAccount(const char *username, const char *password,
		const char *regKey, const char *grovename) {
	if (username == NULL)
		return ACCOUNT_SIZENAME;
	if (password == NULL)
		return ACCOUNT_SIZEPASS;
	if (regKey == NULL)
		return ACCOUNT_KEY;
	if (grovename == NULL)
		return ACCOUNT_SIZEGROVE;

	if (strlen(username) < 3 || strlen(username) > 48)
		return ACCOUNT_SIZENAME;
	if (ValidString(username) == false)
		return ACCOUNT_INVNAME;

	if (FetchAccountByUsername(username) != NULL)
		return ACCOUNT_HASNAME;

	if (strlen(password) < 3 || strlen(password) > 32) // > sizeof(AccountData().AuthPass) - 1)
		return ACCOUNT_SIZEPASS;
	if (ValidString(password) == false)
		return ACCOUNT_INVPASS;

	if (strlen(grovename) < 3 || strlen(grovename) > 32)
		return ACCOUNT_SIZEGROVE;

	std::string adjustedGroveName = grovename;
	if (ValidGroveString(adjustedGroveName) == false)
		return ACCOUNT_INVGROVE;

	ZoneDefInfo *zoneDef = g_ZoneDefManager.GetPointerByGroveName(
			adjustedGroveName.c_str());
	if (zoneDef != NULL)
		return ACCOUNT_HASGROVE;

	//  *****  Everything verified.  Create the account.  *****
	AccountData newAccount;

	newAccount.ID = g_ClusterManager.NextValue(ID_NEXT_ACCOUNT_ID);
	newAccount.CreatedTimeSec = time(NULL);

	newAccount.SetPermission(Perm_Account, "regionchat", true);
	newAccount.SetPermission(Perm_Account, "forumpost", true);

	//Assign username and registration key
	newAccount.Name = username;
	newAccount.SetNewRegistrationKey(regKey);

	//Generate and assign the password hash
	newAccount.SetNewPassword(username, password);

	g_Logs.data->info("Created account: %v:%v", username, newAccount.AuthData);

	//Prepare the grove
	newAccount.GroveName = adjustedGroveName;
	BuildPermissionArea bp;
	bp.ZoneID = g_ZoneDefManager.CreateGrove(newAccount.ID,
			adjustedGroveName.c_str());
	bp.x1 = 0;
	bp.y1 = 0;
	bp.x2 = 3;
	bp.y2 = 3;
	newAccount.BuildPermissionList.push_back(bp);

	g_Logs.event->info("[ACCOUNT] Account created [%v] with %v characters.",
			newAccount.Name, newAccount.GetCharacterCount());

	newAccount.PendingMinorUpdates++;  //Save at the next available opportunity
	AccList.push_back(newAccount);
	AppendQuickData(&newAccount);

	return ACCOUNT_SUCCESS;
}

int AccountManager::CreateAccountFromService(const char *username) {
	if (username == NULL)
		return ACCOUNT_SIZENAME;

	if (strlen(username) < 3 || strlen(username) > 48)
		return ACCOUNT_SIZENAME;
	if (ValidString(username) == false)
		return ACCOUNT_INVNAME;

	if (FetchAccountByUsername(username) != NULL)
		return ACCOUNT_HASNAME;

	AccountData newAccount;

	newAccount.ID = g_ClusterManager.NextValue(ID_NEXT_ACCOUNT_ID);
	newAccount.CreatedTimeSec = time(NULL);
	newAccount.Name = username;

	newAccount.SetPermission(Perm_Account, "regionchat", true);
	newAccount.SetPermission(Perm_Account, "forumpost", true);

	g_Logs.event->info(
			"[ACCOUNT] Account created [%v] with %v characters (via service).",
			newAccount.Name, newAccount.GetCharacterCount());

	newAccount.PendingMinorUpdates++;  //Save at the next available opportunity
	AccList.push_back(newAccount);
	AppendQuickData(&newAccount, true);

	return ACCOUNT_SUCCESS;
}

// Attempt to reset a password, given the supplied information from the password reset web form.
int AccountManager::ResetPassword(const char *username, const char *newpassword,
		const char *regKey, bool checkPermission) {
	if (username == NULL)
		return ACCOUNT_SIZENAME;
	if (newpassword == NULL)
		return ACCOUNT_SIZEPASS;
	if (regKey == NULL)
		return ACCOUNT_KEY;

	if (strlen(newpassword) < 3 || strlen(newpassword) > 32) // > sizeof(AccountData().AuthPass) - 1)
		return ACCOUNT_SIZEPASS;
	if (ValidString(newpassword) == false)
		return ACCOUNT_INVPASS;

	AccountData *accPtr = FetchAccountByUsername(username);
	if (accPtr == NULL)
		return ACCOUNT_USERNOTFOUND;

	if (checkPermission
			&& accPtr->HasPermission(Perm_Account, Permission_PasswordReset)
					== false)
		return ACCOUNT_PERMISSIONRESET;

	if (accPtr->MatchRegistrationKey(regKey) == false)
		return ACCOUNT_REGMISMATCH;

	//Set the new password, then update the quickdata entry.
	accPtr->SetNewPassword(username, newpassword);

	AppendQuickData(accPtr);

	if (checkPermission)
		accPtr->SetPermission(Perm_Account, "passwordreset", false);
	accPtr->PendingMinorUpdates++;
	return ACCOUNT_PASSWORDRESETOK;
}

// Attempt to unlock an account, given the supplied information from the account recovery web form.
int AccountManager::AccountRecover(const char *username, const char *keypass,
		const char *type) {
	if (username == NULL)
		return ACCOUNT_BADUSERNAME;
	if (type == NULL)
		return ACCOUNT_BADREQUEST;

	AccountData *accPtr = FetchAccountByUsername(username);
	AccountQuickData aqd = GetAccountQuickDataByUsername(username);
	if (accPtr == NULL || aqd.mID == 0)
		return ACCOUNT_USERNOTFOUND;

	if (accPtr->RecoveryKeys.size() == 0)
		return ACCOUNT_CANNOTRECOVER;

	if (strcmp(type, "key") == 0) {
		if (keypass == NULL)
			return ACCOUNT_BADKEY;
		if (strlen(keypass) == 0)
			return ACCOUNT_BADKEY;
		std::string key;
		AccountData::GenerateSaltedHash(keypass, key);
		if (accPtr->MatchRecoveryKey(type, key.c_str()) == true) {
			accPtr->FillRegistrationKey(keypass);
			accPtr->RecoveryKeys.clear();
			accPtr->PendingMinorUpdates++;
			AppendQuickData(accPtr);

			return ACCOUNT_SUCCESSRECOVER;
		} else {
			return ACCOUNT_REJECTED;
		}
	} else if (strcmp(type, "password") == 0) {
		if (keypass == NULL)
			return ACCOUNT_BADPASSWORD;
		if (strlen(keypass) == 0)
			return ACCOUNT_BADPASSWORD;

		std::string clientPass;
		std::string serverPass;
		accPtr->GenerateClientPasswordHash(username, keypass, clientPass);
		AccountData::GenerateSaltedHash(clientPass.c_str(), serverPass);

		if (accPtr->MatchRecoveryKey(type, serverPass.c_str()) == true) {
			accPtr->FillAuthorizationHash(serverPass.c_str());
			accPtr->RecoveryKeys.clear();
			accPtr->PendingMinorUpdates++;
			AppendQuickData(accPtr);
			return ACCOUNT_SUCCESSRECOVER;
		} else {
			return ACCOUNT_REJECTED;
		}
	} else {
		return ACCOUNT_BADREQUEST;
	}
}

bool AccountManager::PopRegistrationKey(const std::string &authKey) {
	return g_ClusterManager.ListRemove(KEYPREFIX_REGISTRATION_KEYS, authKey,
			true);
}

bool AccountManager::ValidString(const char *str) {
	size_t len = strlen(str);
	for (size_t i = 0; i < len; i++) {
		if (str[i] <= 32)
			return false;
		if (str[i] >= 127)
			return false;
		if (str[i] == ',' || str[i] == ';' || str[i] == '|' || str[i] == '&')
			return false;
	}
	return true;
}

bool AccountManager::ValidGroveString(std::string &nameToAdjust) {
	for (size_t i = 0; i < nameToAdjust.size(); i++) {
		char c = nameToAdjust[i];
		if (c >= 'A' && c <= 'Z')
			nameToAdjust[i] += 32;
		else if (c < 'a' || c > 'z')
			return false;
	}
	return true;
}

AccessToken* AccountManager::GetToken(std::string token) {
	cs.Enter("AccountManager::GetToken");
	AccessToken *t = Tokens[token];
	if (t != NULL) {
		if (t->uses != -1) {
			if (t->uses < 1) {
				Tokens.erase(Tokens.find(token));
				delete t;
				cs.Leave();
				return NULL;
			}
			t->uses--;
		}
		if (g_ServerTime < t->expire) {
			cs.Leave();
			return t;
		}
		Tokens.erase(Tokens.find(token));
		delete t;

	}
	cs.Leave();
	return NULL;
}

std::string AccountManager::GenerateToken(int accountID, unsigned long ttl,
		int tokenType, int uses) {
	std::string token = Util::RandomHexStr(32);
	AccessToken *t = new AccessToken();
	t->accountID = accountID;
	t->expire = g_ServerTime + ttl;
	t->tokenType = tokenType;
	t->token = token;
	t->uses = uses;
	cs.Enter("AccountManager::GenerateToken");
	Tokens[token] = t;
	cs.Leave();
	return token;
}

AccountData * AccountManager::FetchAccountByUsername(const char *username) {
	ACCOUNT_ITERATOR it;
	for (it = AccList.begin(); it != AccList.end(); ++it)
		if (strcmp(it->Name.c_str(), username) == 0)
			return &*it;

	AccountQuickData qd = GetAccountQuickDataByUsername(username);
	if (qd.mID != 0) {
		return FetchIndividualAccount(qd.mID);
	}
	return NULL;
}

const char * AccountManager::GetErrorMessage(int message) {
	switch (message) {
	case ACCOUNT_SUCCESS:
		return "Account creation was successful.";
	case ACCOUNT_KEY:
		return "Missing or invalid registration key.";
	case ACCOUNT_SIZENAME:
		return "The username must contain between 3-32 characters.";
	case ACCOUNT_INVNAME:
		return "The username contains invalid characters.";
	case ACCOUNT_HASNAME:
		return "That username already exists.";
	case ACCOUNT_SIZEPASS:
		return "The password must contain between 3-32 characters.";
	case ACCOUNT_INVPASS:
		return "The password contains invalid characters.";
	case ACCOUNT_SIZEGROVE:
		return "The grove name must contain between 3-32 characters.";
	case ACCOUNT_INVGROVE:
		return "The grove name contains invalid characters.";
	case ACCOUNT_HASGROVE:
		return "That grove name already exists.";
	case ACCOUNT_REGMISMATCH:
		return "The registration key does not match the one that created the account.";
	case ACCOUNT_PASSWORDRESETOK:
		return "Password was successfully reset.";
	case ACCOUNT_USERNOTFOUND:
		return "The username was not found.";
	case ACCOUNT_PERMISSIONRESET:
		return "The account must be approved for a password reset.";

	case ACCOUNT_BADUSERNAME:
		return "Username was missing or not supplied.";
	case ACCOUNT_BADKEY:
		return "Registration key was missing or not supplied.";
	case ACCOUNT_BADPASSWORD:
		return "Password was missing or not supplied.";
	case ACCOUNT_REJECTED:
		return "Account recover failed, information does not match.";
	case ACCOUNT_SUCCESSRECOVER:
		return "The account was recovered successfully.";
	case ACCOUNT_BADREQUEST:
		return "The required information was malformed or incomplete.";
	case ACCOUNT_CANNOTRECOVER:
		return "This account cannot be recovered.  If recovered before, it cannot be recovered again.";
	default:
		return "Unknown error.";
	}
}

const char * AccountManager::GetCharacterErrorMessage(int message) {
	switch (message) {
	case CHARACTER_SUCCESS:
		return "OK";
	case CHARACTER_INVQUERY:
		return "Invalid or malformed query.";
	case CHARACTER_NOSLOTS:
		return "No free character slots. You may purchase additional slots from the Credit Shop, up to a total of 8.";
	case CHARACTER_FIRSTINV:
		return "Invalid first name.";
	case CHARACTER_FIRSTSHORT:
		return "First name is too short.";
	case CHARACTER_FIRSTLONG:
		return "First name is too long.";
	case CHARACTER_LASTINV:
		return "Invalid last name.";
	case CHARACTER_LASTSHORT:
		return "Last name is too short.";
	case CHARACTER_LASTLONG:
		return "Last name is too long.";
	case CHARACTER_NAMEEXIST:
		return "A character with that name already exists.";
	default:
		return "Unknown error.";
	}
}

int AccountManager::HasPendingMinorUpdates(void) {
	int pendingCount = 0;
	ACCOUNT_ITERATOR it;
	for (it = AccList.begin(); it != AccList.end(); ++it)
		pendingCount += it->PendingMinorUpdates;

	return pendingCount;
}

bool AccountManager::ValidCharacterName(const std::string &name) {
	for (size_t i = 0; i < name.size(); i++) {
		bool valid = false;
		if (name[i] >= 'A' && name[i] <= 'Z')
			valid = true;
		if (name[i] >= 'a' && name[i] <= 'z')
			valid = true;
		if (valid == false)
			return false;
	}
	return true;
}

int AccountManager::ValidateNameParts(const std::string &first,
		const std::string &last) {
	if (first.size() == 0)
		return CHARACTER_FIRSTSHORT;
	if (first.size() > 16)
		return CHARACTER_FIRSTLONG;
	if (last.size() == 0)
		return CHARACTER_LASTSHORT;
	if (last.size() > 16)
		return CHARACTER_LASTLONG;

	if (ValidCharacterName(first) == 0)
		return CHARACTER_FIRSTINV;

	if (ValidCharacterName(last) == 0)
		return CHARACTER_LASTINV;

	//Check character name
	if (g_UsedNameDatabase.HasName(
			StringUtil::Format("%s %s", first.c_str(), last.c_str())))
		return CHARACTER_NAMEEXIST;

	return CHARACTER_SUCCESS;
}

int AccountManager::CreateCharacter(STRINGLIST &args, AccountData *accPtr,
		CharacterData &newChar) {
	// Safeguard to make sure the query is valid.
	// Variable elements begin at index [11]. All previous elements must exist.
	if (args.size() <= 12)
		return CHARACTER_INVQUERY;

	int r = accPtr->GetFreeCharacterSlot();
	if (r >= 0) {
		int rr = ValidateNameParts(args[0], args[1]);
		if (rr != CHARACTER_SUCCESS) {
			return rr;
		}

		// The first name may only be sage if the account has sage permissons
		if (Util::CaseInsensitiveStringCompare(args[0], "Sage")
				&& !accPtr->HasPermission(Perm_Account, Permission_Sage)) {
			return CHARACTER_FIRSTINV;
		}

		int newID = GetNewCharacterID();
		accPtr->CharacterSet[r] = newID;

		newChar.CopyFrom(*g_CharacterManager.GetDefaultCharacter());
		newChar.CreatedTimeSec = time(NULL);
		newChar.cdef.CreatureDefID = newID;
		newChar.cdef.DefHints = 1;
		newChar.pendingChanges = 1;
		newChar.SetExpireTime();

		//Character name is in buffer, from above
		char buffer[3072];
		sprintf(buffer, "%s %s", args[0].c_str(), args[1].c_str());
		Util::SafeCopy(newChar.cdef.css.display_name, buffer,
				sizeof(newChar.cdef.css.display_name));

		static const char *RaceNames[4] = { "Knight", "Rogue", "Mage", "Druid" };
		int prof = 0;
		for (int a = 0; a < 4; a++) {
			if (args[2].compare(RaceNames[a]) == 0) {
				prof = a;
				break;
			}
		}
		newChar.cdef.css.profession = prof + 1;
		newChar.cdef.css.level = 1;
		newChar.UpdateBaseStats(NULL, true);
		newChar.cdef.css.health = newChar.cdef.css.constitution
				* HealthConModifier;
		newChar.cdef.css.will = 10;
		newChar.cdef.css.will_regen = 1.0F;
		newChar.cdef.css.might = 10;
		newChar.cdef.css.might_regen = 1.0F;

		newChar.AbilityRespec(NULL);

		int wpos = 0;
		wpos += sprintf(&buffer[wpos], "c2:{");
		wpos += sprintf(&buffer[wpos], "[\"h\"]=%s,", args[6].c_str());
		wpos += sprintf(&buffer[wpos], "[\"b\"]=\"%s\",", args[5].c_str());
		wpos += sprintf(&buffer[wpos], "[\"r\"]=\"%s\",", args[3].c_str());
		wpos += sprintf(&buffer[wpos], "[\"g\"]=\"%s\",", args[4].c_str());

		// For some reason the client is set to default as 0.85, but the
		// size slider ranges from 0.9 to 1.1
		if (args[7].compare("0.85") == 0)
			args[7] = "1.0";
		wpos += sprintf(&buffer[wpos], "[\"sz\"]=\"%s\",", args[7].c_str());
		wpos += sprintf(&buffer[wpos], "[\"ts\"]=\"%s\",", args[11].c_str());
		wpos += sprintf(&buffer[wpos], "[\"es\"]=\"%s\",", args[12].c_str());

		wpos += sprintf(&buffer[wpos], "[\"sk\"]={");
		for (size_t i = 13; i < args.size(); i += 2)
			wpos += sprintf(&buffer[wpos], "[\"%s\"]=\"%s\",", args[i].c_str(),
					args[i + 1].c_str());

		wpos--;  //Step back to remove the trailing comma

		wpos += sprintf(&buffer[wpos], "}}"); //Close both the ["sk"] and "c2:" tables.

		//g_Log.AddMessageFormat("Creating string: [%s]", buffer);

		//strncpy(newChar.cdef.css.appearance, buffer, sizeof(newChar.cdef.css.appearance) - 1);
		newChar.cdef.css.SetAppearance(buffer);

		//Set the starting items.
		int shirtIndex = atoi(args[8].c_str());
		int pantsIndex = atoi(args[9].c_str());
		int bootsIndex = atoi(args[10].c_str());

		//Banded Tunic, Leather Tunic, Cloth Vest, Wool Vestment, Twill Tunic
		static const int shirtArray[5] = { 3019, 1844, 2810, 3160, 2107 };

		//Banded Leggings, Leather Pants, Cloth Wrap, Wool Leg Wraps, Twill Pants
		static const int pantsArray[5] = { 3008, 3158, 1980, 3161, 2442 };

		//Banded Boots, Leather Boots, Cloth Shoes, Wool Shoes, Twill Boots
		static const int bootsArray[5] = { 2831, 3159, 2108, 3162, 2898 };

		//Starting Druid equipment.
		//{[0]=143606,[2]=143609,[6]=3160,[10]=3161,[11]=3162}
		InventoryManager &inventory = newChar.inventory;
		InventorySlot item;

		item.CCSID = inventory.GetCCSID(EQ_CONTAINER,
				ItemEquipSlot::ARMOR_CHEST);
		item.IID = shirtArray[shirtIndex];
		inventory.containerList[EQ_CONTAINER].push_back(item);

		item.CCSID = inventory.GetCCSID(EQ_CONTAINER,
				ItemEquipSlot::ARMOR_LEGS);
		item.IID = pantsArray[pantsIndex];
		inventory.containerList[EQ_CONTAINER].push_back(item);

		item.CCSID = inventory.GetCCSID(EQ_CONTAINER,
				ItemEquipSlot::ARMOR_FEET);
		item.IID = bootsArray[bootsIndex];
		inventory.containerList[EQ_CONTAINER].push_back(item);

		//Knight: Sword + Shield
		//Rogue: Dagger + Dagger
		//Mage: Wand
		//Druid: Bow

		if (prof == 0)  //Knight = 141760:Sword, 3163:Banded Buckler
				{
			item.CCSID = inventory.GetCCSID(EQ_CONTAINER,
					ItemEquipSlot::WEAPON_MAIN_HAND);
			item.IID = 141760;
			inventory.containerList[EQ_CONTAINER].push_back(item);

			item.CCSID = inventory.GetCCSID(EQ_CONTAINER,
					ItemEquipSlot::WEAPON_OFF_HAND);
			item.IID = 3163;
			inventory.containerList[EQ_CONTAINER].push_back(item);
		} else if (prof == 1)  //Rogue = 141763:Short Blade, 141764:Small Dagger
				{
			item.CCSID = inventory.GetCCSID(EQ_CONTAINER,
					ItemEquipSlot::WEAPON_MAIN_HAND);
			item.IID = 141763;
			inventory.containerList[EQ_CONTAINER].push_back(item);

			item.CCSID = inventory.GetCCSID(EQ_CONTAINER,
					ItemEquipSlot::WEAPON_OFF_HAND);
			item.IID = 141764;
			inventory.containerList[EQ_CONTAINER].push_back(item);
		} else if (prof == 2)  //Mage = 141765:Wand
				{
			item.CCSID = inventory.GetCCSID(EQ_CONTAINER,
					ItemEquipSlot::WEAPON_RANGED);
			item.IID = 141765;
			inventory.containerList[EQ_CONTAINER].push_back(item);
		} else if (prof == 3)  //Druid = 143609:Bow
				{
			item.CCSID = inventory.GetCCSID(EQ_CONTAINER,
					ItemEquipSlot::WEAPON_RANGED);
			item.IID = 143609;
			inventory.containerList[EQ_CONTAINER].push_back(item);
		}

		newChar.UpdateEqAppearance();
		newChar.OnCharacterCreation();
		newChar.OnFinishedLoading();
		newChar.AccountID = accPtr->ID;

		newChar.bindReturnPoint[0] = g_InfoManager.GetStartX();
		newChar.bindReturnPoint[1] = g_InfoManager.GetStartY();
		newChar.bindReturnPoint[2] = g_InfoManager.GetStartZ();
		newChar.bindReturnPoint[3] = g_InfoManager.GetStartZone();
		newChar.cdef.css.translocate_destination =
				g_ZoneDefManager.GetPointerByID(g_InfoManager.GetStartZone())->mName;

		g_CharacterManager.AddExternalCharacter(newChar.cdef.CreatureDefID,
				newChar);
		g_UsedNameDatabase.Add(newChar.cdef.CreatureDefID,
				newChar.cdef.css.display_name);

		CharacterCacheEntry entry;
		entry.Clear();
		entry.creatureDefID = newChar.cdef.CreatureDefID;
		entry.level = newChar.cdef.css.level;
		entry.profession = newChar.cdef.css.profession;
		entry.display_name = newChar.cdef.css.display_name;
		entry.appearance = newChar.cdef.css.appearance;
		entry.eq_appearance = newChar.cdef.css.eq_appearance;
		accPtr->characterCache.AddEntry(entry);

		accPtr->PendingMinorUpdates++;

		/*[Sim:0]   [0]=Test
		 [Sim:0]   [1]=Character
		 [Sim:0]   [2]=Druid
		 [Sim:0]   [3]=g
		 [Sim:0]   [4]=m
		 [Sim:0]   [5]=n
		 [Sim:0]   [6]=0
		 [Sim:0]   [7]=0.85
		 [Sim:0]   [8]=2
		 [Sim:0]   [9]=1
		 [Sim:0]   [10]=0
		 [Sim:0]   [11]=hands_feet
		 [Sim:0]   [12]=8e95a7
		 [Sim:0]   [13]=inner_ear
		 [Sim:0]   [14]=d8c0b6
		 [Sim:0]   [15]=nails
		 [Sim:0]   [16]=56514a
		 [Sim:0]   [17]=mask
		 [Sim:0]   [18]=9891ac
		 [Sim:0]   [19]=base
		 [Sim:0]   [20]=8d86a1
		 [Sim:0]   [21]=head_highlight
		 [Sim:0]   [22]=d4a86b
		 [Sim:0]   [23]=eye
		 [Sim:0]   [24]=71a6ac
		 [Sim:0]   [25]=eye_white
		 [Sim:0]   [26]=b1a5a5
		 [Sim:0]   [27]=nose
		 [Sim:0]   [28]=7e7890
		 [Sim:0]   [29]=chest
		 [Sim:0]   [30]=b9aaa0
		 */

	} else {
		return CHARACTER_NOSLOTS;
	}
	return r; //return the character index
}

int AccountManager::GetNewCharacterID(void) {
	return g_ClusterManager.NextValue(ID_NEXT_CHARACTER_ID,
			CHARACTER_ID_INCREMENT);
}

void AccountManager::DeleteCharacter(int index, AccountData *accPtr) {
	if (index < 0 || index >= accPtr->MAX_CHARACTER_SLOTS)
		return;

	int CDefID = accPtr->CharacterSet[index];
	if (CDefID == 0)
		return;

	cs.Enter("AccountManager::DeleteCharacter");

	for (int i = index; i < AccountData::MAX_CHARACTER_SLOTS - 1; i++)
		accPtr->CharacterSet[i] = accPtr->CharacterSet[i + 1];
	accPtr->CharacterSet[AccountData::MAX_CHARACTER_SLOTS - 1] = 0;
	accPtr->characterCache.RemoveCharacter(CDefID);
	g_FriendListManager.DeleteCharacter(CDefID);
	accPtr->PendingMinorUpdates++;

	g_Logs.event->info("[CHARACTER] Deleted character ID:%v", CDefID);

	g_UsedNameDatabase.Remove(CDefID);

	cs.Leave();
}

void AccountManager::AppendQuickData(AccountData *account, bool sync) {
	AccountQuickData object;
	object.mID = account->ID;
	object.mLoginName = account->Name;
	object.mLoginAuth = account->AuthData;
	object.mRegKey = account->RegKey;
	object.mGroveName = account->GroveName;

	g_ClusterManager.WriteEntity(&object, sync);
}

AccountData * AccountManager::GetActiveAccountByID(int accountID) {
	ACCOUNT_ITERATOR it;
	for (it = AccList.begin(); it != AccList.end(); ++it)
		if (it->ID == accountID)
			return &*it;
	return NULL;
}

AccountData * AccountManager::FetchIndividualAccount(int accountID) {
	AccountData *search = GetActiveAccountByID(accountID);
	if (search != NULL)
		return search;

	//Not found, load it.
	return LoadAccountID(accountID);
}

AccountData * AccountManager::LoadAccountID(int accountID) {
	AccountData accData;
	accData.ID = accountID;
	if (g_ClusterManager.ReadEntity(&accData)) {
		g_Logs.data->info("Account %v was loaded from the cluster OK.",
				accountID);
	} else {
		g_Logs.data->error("Failed to open account: %v", accountID);
	}

	AccList.push_back(accData);

	if (AccList.size() > 0)
		if (AccList.back().ID == accountID)
			return &AccList.back();

	g_Logs.data->error("Failed to retrieve account: %v", accountID);
	return NULL;
}

void AccountManager::LoadAllData(void) {
	if (!g_ClusterManager.HasKey(ID_NEXT_CHARACTER_ID)) {
		g_ClusterManager.SetKey(ID_NEXT_CHARACTER_ID,
				StringUtil::Format("%d", DEFAULT_CHARACTER_ID));
	}
}

void AccountManager::UnloadAllData(void) {
	AccList.clear();
}

void AccountManager::SaveIndividualAccount(AccountData *account) {
	if (!g_ClusterManager.WriteEntity(account))
		g_Logs.data->error("SaveAccountToStream could not save: %v",
				account->ID);
}

void AccountManager::RunUpdateCycle(bool force) {
	if (TimerGeneralUpdate.ReadyWithUpdate(GENERAL_UPDATE_FREQUENCY) == false
			&& force == false)
		return;

	ACCOUNT_ITERATOR it;
	it = AccList.begin();
	while (it != AccList.end()) {
		if (it->PendingMinorUpdates > 0) {
			SaveIndividualAccount(&*it);
			it->PendingMinorUpdates = 0;
			g_Logs.data->info("Saved account: %v", it->ID);
		}

		if (it->QualifyGarbage(force) == true) {
			g_Logs.event->info("[ACCOUNT] Unloading account: %v", it->ID);
			AccList.erase(it++);
		} else
			++it;
	}
}

void AccountManager::ImportKey(const char *key) {
	g_ClusterManager.ListAdd(KEYPREFIX_REGISTRATION_KEYS, key, false);
	g_Logs.server->info("Single key imported from external source");
}

bool AccountManager::AcceptingLogins(void) {
	return true;
}

CharacterCacheEntry* CharacterCacheManager::GetCacheCharacter(int cdefID) {
	//Searches the cache for a character, but will not load it if it doesn't exist.
	for (size_t i = 0; i < cacheData.size(); i++)
		if (cacheData[i].creatureDefID == cdefID)
			return &cacheData[i];
	return NULL;
}

CharacterCacheEntry* CharacterCacheManager::ForceGetCharacter(int cdefID) {
	//Search the cache for a character. If it doesn't exist, load the character file.
	CharacterCacheEntry *cce = GetCacheCharacter(cdefID);
	if (cce == NULL) {
		g_Logs.data->info("Loading character entry [%v] into cache", cdefID);
		CharacterData *charData = g_CharacterManager.RequestCharacter(cdefID,
				true);
		if (charData == NULL)
			charData = g_CharacterManager.GetDefaultCharacter();
		if (charData != NULL)
			cce = UpdateCharacter(charData);
	} else
		g_Logs.data->info("Retrieved character entry [%v] from cache", cdefID);
	return cce;
}

CharacterCacheEntry* CharacterCacheManager::UpdateCharacter(
		CharacterData *charData) {
	if (charData == NULL)
		return NULL;

	CharacterCacheEntry *entry = NULL;
	entry = GetCacheCharacter(charData->cdef.CreatureDefID);
	if (entry == NULL) {
		size_t osize = cacheData.size();
		cacheData.push_back(CharacterCacheEntry());
		size_t nsize = cacheData.size();
		if (nsize > osize)  //Verify it was added to retrieve its pointer.
			entry = &cacheData.back();
	}

	if (entry == NULL) {
		g_Logs.data->error("UpdateCharacter() failed");
		return NULL;
	}

	entry->creatureDefID = charData->cdef.CreatureDefID;
	entry->level = charData->cdef.css.level;
	entry->profession = charData->cdef.css.profession;
	entry->display_name = charData->cdef.css.display_name;
	entry->appearance = charData->cdef.css.appearance;
	entry->eq_appearance = charData->cdef.css.eq_appearance;
	return entry;
}

void CharacterCacheManager::RemoveCharacter(int cdefID) {
	for (size_t i = 0; i < cacheData.size(); i++) {
		if (cacheData[i].creatureDefID == cdefID) {
			g_ClusterManager.RemoveKey(StringUtil::Format("%s:%s", KEYPREFIX_CHARACTER_NAME_TO_ID.c_str(), cacheData[i].display_name.c_str()));
			CharacterData *cd = g_CharacterManager.RequestCharacter(cdefID, true);
			if(cd != NULL) {
				g_ClusterManager.RemoveEntity(cd);
			}
			cacheData.erase(cacheData.begin() + i);
			return;
		}
	}
}

bool CharacterCacheManager::ReadEntity(AbstractEntityReader *reader) {

	STRINGLIST sections = reader->Sections();
//	cacheData.clear();
	int i = 0;
	for (auto a = sections.begin(); a != sections.end(); ++a) {
		CharacterCacheEntry e;
		reader->PushSection(StringUtil::Format("CACHEENTRY#%d", i++));
		bool ok = e.ReadEntity(reader);
		reader->PopSection();
		if (!ok)
			return false;
		cacheData.push_back(e);
	}
	return true;
}

bool CharacterCacheManager::WriteEntity(AbstractEntityWriter *writer) {
	for (size_t i = 0; i < cacheData.size(); i++) {
		writer->PushSection(StringUtil::Format("CACHEENTRY#%d", i));
		bool ok = cacheData[i].WriteEntity(writer);
		writer->PopSection();
		if (!ok)
			return false;
	}
	return true;
}

void CharacterCacheManager::AddEntry(CharacterCacheEntry &data) {
	cacheData.push_back(data);
}

UsedNameDatabase::UsedNameDatabase() {
}

UsedNameDatabase::~UsedNameDatabase() {
}

void UsedNameDatabase::Add(int CDefID, const std::string &name) {
	g_ClusterManager.SetKey(
			StringUtil::Format("%s:%s", KEYPREFIX_CHARACTER_NAME_TO_ID.c_str(),
					name.c_str()), StringUtil::Format("%d", CDefID));
	g_ClusterManager.SetKey(
			StringUtil::Format("%s:%d", KEYPREFIX_CHARACTER_ID_TO_NAME.c_str(),
					CDefID), name.c_str());
}

void UsedNameDatabase::Remove(int CDefID) {
	std::string name = GetNameByID(CDefID);
	if (name.length() > 0)
		g_ClusterManager.RemoveKey(
				StringUtil::Format("%s:%s", KEYPREFIX_CHARACTER_NAME_TO_ID,
						name.c_str()));
	g_ClusterManager.RemoveKey(
			StringUtil::Format("%s:%d", KEYPREFIX_CHARACTER_ID_TO_NAME.c_str(),
					CDefID));
}

bool UsedNameDatabase::HasID(int CDefID) {
	return g_ClusterManager.HasKey(
			StringUtil::Format("%s:%d", KEYPREFIX_CHARACTER_ID_TO_NAME.c_str(),
					CDefID));
}

const char* UsedNameDatabase::GetNameByID(int CDefID) {
	return g_ClusterManager.GetKey(
			StringUtil::Format("%s:%d", KEYPREFIX_CHARACTER_ID_TO_NAME.c_str(),
					CDefID)).c_str();
}

int UsedNameDatabase::GetIDByName(const std::string &name) {
	return atoi(
			g_ClusterManager.GetKey(
					StringUtil::Format("%s:%d",
							KEYPREFIX_CHARACTER_NAME_TO_ID.c_str(),
							name.c_str())).c_str());
}

bool UsedNameDatabase::HasName(const std::string &name) {
	return g_ClusterManager.HasKey(
			StringUtil::Format("%s:%d", KEYPREFIX_CHARACTER_NAME_TO_ID.c_str(),
					name.c_str()));
}

